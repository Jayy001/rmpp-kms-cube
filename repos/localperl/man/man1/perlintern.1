.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PERLINTERN 1"
.TH PERLINTERN 1 2024-09-20 "perl v5.40.0" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
perlintern \- autogenerated documentation of purely internal
Perl functions
.SH DESCRIPTION
.IX Xref "internal Perl functions interpreter functions"
.IX Header "DESCRIPTION"
This file is the autogenerated documentation of functions in the
Perl interpreter that are documented using Perl's internal documentation
format but are not marked as part of the Perl API.  In other words,
\&\fBthey are not for use in extensions\fR!
.PP
It has the same sections as perlapi, though some may be empty.
.SH "AV Handling"
.IX Header "AV Handling"
.ie n .IP """av_fetch_simple""" 4
.el .IP \f(CWav_fetch_simple\fR 4
.IX Xref "av_fetch_simple"
.IX Item "av_fetch_simple"
This is a cut-down version of av_fetch that assumes that the array is
very straightforward \- no magic, not readonly, and AvREAL \- and that
\&\f(CW\*(C`key\*(C'\fR is not negative. This function MUST NOT be used in situations
where any of those assumptions may not hold.
.Sp
Returns the SV at the specified index in the array.  The \f(CW\*(C`key\*(C'\fR is the
index.  If lval is true, you are guaranteed to get a real SV back (in case
it wasn't real before), which you can then modify.  Check that the return
value is non-null before dereferencing it to a \f(CW\*(C`SV*\*(C'\fR.
.Sp
The rough perl equivalent is \f(CW$myarray[$key]\fR.
.RS 4
.Sp
.Vb 1
\& SV **  av_fetch_simple(AV *av, SSize_t key, I32 lval)
.Ve
.RE
.RS 4
.RE
.ie n .IP """AvFILLp""" 4
.el .IP \f(CWAvFILLp\fR 4
.IX Xref "AvFILLp"
.IX Item "AvFILLp"
If the array \f(CW\*(C`av\*(C'\fR is empty, this returns \-1; otherwise it returns the maximum
value of the indices of all the array elements which are currently defined in
\&\f(CW\*(C`av\*(C'\fR.  It does not handle magic, hence the \f(CW\*(C`p\*(C'\fR private indication in its name.
.RS 4
.Sp
.Vb 1
\& SSize_t  AvFILLp(AV* av)
.Ve
.RE
.RS 4
.RE
.ie n .IP """av_new_alloc""" 4
.el .IP \f(CWav_new_alloc\fR 4
.IX Xref "av_new_alloc"
.IX Item "av_new_alloc"
This implements "\f(CW\*(C`newAV_alloc_x\*(C'\fR" in perlapi
and "\f(CW\*(C`newAV_alloc_xz\*(C'\fR" in perlapi, which are the public API for this
functionality.
.Sp
Creates a new AV and allocates its SV* array.
.Sp
This is similar to, but more efficient than doing:
.Sp
.Vb 2
\&    AV *av = newAV();
\&    av_extend(av, key);
.Ve
.Sp
The size parameter is used to pre-allocate a SV* array large enough to
hold at least elements \f(CW\*(C`0..(size\-1)\*(C'\fR.  \f(CW\*(C`size\*(C'\fR must be at least 1.
.Sp
The \f(CW\*(C`zeroflag\*(C'\fR parameter controls whether or not the array is NULL
initialized.
.RS 4
.Sp
.Vb 1
\& AV *  av_new_alloc(SSize_t size, bool zeroflag)
.Ve
.RE
.RS 4
.RE
.ie n .IP """av_store_simple""" 4
.el .IP \f(CWav_store_simple\fR 4
.IX Xref "av_store_simple"
.IX Item "av_store_simple"
This is a cut-down version of av_store that assumes that the array is
very straightforward \- no magic, not readonly, and AvREAL \- and that
\&\f(CW\*(C`key\*(C'\fR is not negative. This function MUST NOT be used in situations
where any of those assumptions may not hold.
.Sp
Stores an SV in an array.  The array index is specified as \f(CW\*(C`key\*(C'\fR. It
can be dereferenced to get the \f(CW\*(C`SV*\*(C'\fR that was stored there (= \f(CW\*(C`val\*(C'\fR)).
.Sp
Note that the caller is responsible for suitably incrementing the reference
count of \f(CW\*(C`val\*(C'\fR before the call.
.Sp
Approximate Perl equivalent: \f(CW\*(C`splice(@myarray, $key, 1, $val)\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& SV **  av_store_simple(AV *av, SSize_t key, SV *val)
.Ve
.RE
.RS 4
.RE
.SH "Callback Functions"
.IX Header "Callback Functions"
.ie n .IP """dowantarray""" 4
.el .IP \f(CWdowantarray\fR 4
.IX Xref "dowantarray"
.IX Item "dowantarray"
\&\f(CW\*(C`\fR\f(CBDEPRECATED!\fR\f(CW\*(C'\fR  It is planned to remove \f(CW\*(C`dowantarray\*(C'\fR
from a future release of Perl.  Do not use it for
new code; remove it from existing code.
.Sp
Implements the deprecated "\f(CW\*(C`GIMME\*(C'\fR" in perlapi.
.RS 4
.Sp
.Vb 1
\& U8  dowantarray()
.Ve
.RE
.RS 4
.RE
.ie n .IP """leave_scope""" 4
.el .IP \f(CWleave_scope\fR 4
.IX Xref "leave_scope"
.IX Item "leave_scope"
Implements \f(CW\*(C`LEAVE_SCOPE\*(C'\fR which you should use instead.
.RS 4
.Sp
.Vb 1
\& void  leave_scope(I32 base)
.Ve
.RE
.RS 4
.RE
.ie n .IP """magic_freedestruct""" 4
.el .IP \f(CWmagic_freedestruct\fR 4
.IX Xref "magic_freedestruct"
.IX Item "magic_freedestruct"
This function is called via magic to implement the
\&\f(CWmortal_destructor_sv()\fR and \f(CWmortal_destructor_x()\fR functions. It
should not be called directly and has no user servicable parts.
.RS 4
.Sp
.Vb 1
\& int  magic_freedestruct(SV *sv, MAGIC *mg)
.Ve
.RE
.RS 4
.RE
.ie n .IP """mortal_svfunc_x""" 4
.el .IP \f(CWmortal_svfunc_x\fR 4
.IX Xref "mortal_svfunc_x"
.IX Item "mortal_svfunc_x"
This function arranges for a C function reference to be called at the
\&\fBend of the current statement\fR with the arguments provided. It is a
wrapper around \f(CWmortal_destructor_sv()\fR which ensures that the latter
function is called appropriately.
.Sp
Be aware that there is a signficant difference in timing between the
\&\fIend of the current statement\fR and the \fIend of the current pseudo
block\fR. If you are looking for a mechanism to trigger a function at the
end of the \fBcurrent pseudo block\fR you should look at
"\f(CW\*(C`SAVEDESTRUCTOR_X\*(C'\fR" in perlapi instead of this function.
.RS 4
.Sp
.Vb 1
\& void  mortal_svfunc_x(SVFUNC_t f, SV *p)
.Ve
.RE
.RS 4
.RE
.ie n .IP """pop_scope""" 4
.el .IP \f(CWpop_scope\fR 4
.IX Xref "pop_scope"
.IX Item "pop_scope"
Implements "\f(CW\*(C`LEAVE\*(C'\fR" in perlapi
.RS 4
.Sp
.Vb 1
\& void  pop_scope()
.Ve
.RE
.RS 4
.RE
.ie n .IP """push_scope""" 4
.el .IP \f(CWpush_scope\fR 4
.IX Xref "push_scope"
.IX Item "push_scope"
Implements "\f(CW\*(C`ENTER\*(C'\fR" in perlapi
.RS 4
.Sp
.Vb 1
\& void  push_scope()
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_adelete""" 4
.el .IP \f(CWsave_adelete\fR 4
.IX Xref "save_adelete"
.IX Item "save_adelete"
Implements \f(CW\*(C`SAVEADELETE\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& void  save_adelete(AV *av, SSize_t key)
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_freercpv""" 4
.el .IP \f(CWsave_freercpv\fR 4
.IX Xref "save_freercpv"
.IX Item "save_freercpv"
Implements \f(CW\*(C`SAVEFREERCPV\*(C'\fR.
.Sp
Saves and frees a refcounted string. Calls \fBrcpv_free()\fR
on the argument when the current pseudo block is finished.
.RS 4
.Sp
.Vb 1
\& void  save_freercpv(char *rcpv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_generic_pvref""" 4
.el .IP \f(CWsave_generic_pvref\fR 4
.IX Xref "save_generic_pvref"
.IX Item "save_generic_pvref"
Implements \f(CW\*(C`SAVEGENERICPV\*(C'\fR.
.Sp
Like \fBsave_pptr()\fR, but also \fBSafefree()\fRs the new value if it is different
from the old one.  Can be used to restore a global char* to its prior
contents, freeing new value.
.RS 4
.Sp
.Vb 1
\& void  save_generic_pvref(char **str)
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_generic_svref""" 4
.el .IP \f(CWsave_generic_svref\fR 4
.IX Xref "save_generic_svref"
.IX Item "save_generic_svref"
Implements \f(CW\*(C`SAVEGENERICSV\*(C'\fR.
.Sp
Like \fBsave_sptr()\fR, but also \fBSvREFCNT_dec()\fRs the new value.  Can be used to
restore a global SV to its prior contents, freeing new value.
.RS 4
.Sp
.Vb 1
\& void  save_generic_svref(SV **sptr)
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_hdelete""" 4
.el .IP \f(CWsave_hdelete\fR 4
.IX Xref "save_hdelete"
.IX Item "save_hdelete"
Implements \f(CW\*(C`SAVEHDELETE\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& void  save_hdelete(HV *hv, SV *keysv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_hints""" 4
.el .IP \f(CWsave_hints\fR 4
.IX Xref "save_hints"
.IX Item "save_hints"
Implements \f(CW\*(C`SAVEHINTS\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& void  save_hints()
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_op""" 4
.el .IP \f(CWsave_op\fR 4
.IX Xref "save_op"
.IX Item "save_op"
Implements \f(CW\*(C`SAVEOP\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& void  save_op()
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_padsv_and_mortalize""" 4
.el .IP \f(CWsave_padsv_and_mortalize\fR 4
.IX Xref "save_padsv_and_mortalize"
.IX Item "save_padsv_and_mortalize"
Implements \f(CW\*(C`SAVEPADSVANDMORTALIZE\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& void  save_padsv_and_mortalize(PADOFFSET off)
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_pushptr""" 4
.el .IP \f(CWsave_pushptr\fR 4
.IX Xref "save_pushptr"
.IX Item "save_pushptr"
The refcnt of object \f(CW\*(C`ptr\*(C'\fR will be decremented at the end of the current
\&\fIpseudo-block\fR.  \f(CW\*(C`type\*(C'\fR gives the type of \f(CW\*(C`ptr\*(C'\fR, expressed as one of the
constants in \fIscope.h\fR whose name begins with \f(CW\*(C`SAVEt_\*(C'\fR.
.Sp
This is the underlying implementation of several macros, like
\&\f(CW\*(C`SAVEFREESV\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& void  save_pushptr(void * const ptr, const int type)
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_rcpv""" 4
.el .IP \f(CWsave_rcpv\fR 4
.IX Xref "save_rcpv"
.IX Item "save_rcpv"
Implements \f(CW\*(C`SAVERCPV\*(C'\fR.
.Sp
Saves and restores a refcounted string, similar to what
save_generic_svref would do for a SV*. Can be used to restore
a refcounted string to its previous state. Performs the 
appropriate refcount counting so that nothing should leak
or be prematurely freed.
.RS 4
.Sp
.Vb 1
\& void  save_rcpv(char **prcpv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_scalar_at""" 4
.el .IP \f(CWsave_scalar_at\fR 4
.IX Xref "save_scalar_at"
.IX Item "save_scalar_at"
A helper function for localizing the SV referenced by \f(CW*sptr\fR.
.Sp
If \f(CW\*(C`SAVEf_KEEPOLDELEM\*(C'\fR is set in in \f(CW\*(C`flags\*(C'\fR, the function returns the input
scalar untouched.
.Sp
Otherwise it replaces \f(CW*sptr\fR with a new \f(CW\*(C`undef\*(C'\fR scalar, and returns that.
The new scalar will have the old one's magic (if any) copied to it.
If there is such magic, and \f(CW\*(C`SAVEf_SETMAGIC\*(C'\fR is set in in \f(CW\*(C`flags\*(C'\fR, 'set'
magic will be processed on the new scalar.  If unset, 'set' magic will be
skipped.  The latter typically means that assignment will soon follow (\fIe.g.\fR,
\&\f(CW\*(Aqlocal\ $x\ =\ $y\*(Aq\fR), and that will handle the magic.
.RS 4
.Sp
.Vb 1
\& SV *  save_scalar_at(SV **sptr, const U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_set_svflags""" 4
.el .IP \f(CWsave_set_svflags\fR 4
.IX Xref "save_set_svflags"
.IX Item "save_set_svflags"
Implements \f(CW\*(C`SAVESETSVFLAGS\*(C'\fR.
.Sp
Set the SvFLAGS specified by mask to the values in val
.RS 4
.Sp
.Vb 1
\& void  save_set_svflags(SV *sv, U32 mask, U32 val)
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_shared_pvref""" 4
.el .IP \f(CWsave_shared_pvref\fR 4
.IX Xref "save_shared_pvref"
.IX Item "save_shared_pvref"
Implements \f(CW\*(C`SAVESHAREDPV\*(C'\fR.
.Sp
Like \fBsave_generic_pvref()\fR, but uses \fBPerlMemShared_free()\fR rather than \fBSafefree()\fR.
Can be used to restore a shared global char* to its prior
contents, freeing new value.
.RS 4
.Sp
.Vb 1
\& void  save_shared_pvref(char **str)
.Ve
.RE
.RS 4
.RE
.ie n .IP """save_vptr""" 4
.el .IP \f(CWsave_vptr\fR 4
.IX Xref "save_vptr"
.IX Item "save_vptr"
Implements \f(CW\*(C`SAVEVPTR\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& void  save_vptr(void *ptr)
.Ve
.RE
.RS 4
.RE
.SH Casting
.IX Xref "NUM2PTR"
.IX Header "Casting"
There are currently no internal API items in Casting
.SH "Character case changing"
.IX Header "Character case changing"
There are currently no internal API items in Character case changing
.SH "Character classification"
.IX Header "Character classification"
There are currently no internal API items in Character classification
.SH "Compiler and Preprocessor information"
.IX Header "Compiler and Preprocessor information"
There are currently no internal API items in Compiler and Preprocessor information
.SH "Compiler directives"
.IX Header "Compiler directives"
There are currently no internal API items in Compiler directives
.SH "Compile-time scope hooks"
.IX Header "Compile-time scope hooks"
.ie n .IP """BhkENTRY""" 4
.el .IP \f(CWBhkENTRY\fR 4
.IX Xref "BhkENTRY"
.IX Item "BhkENTRY"
NOTE: \f(CW\*(C`BhkENTRY\*(C'\fR is \fBexperimental\fR and may change or be
removed without notice.
.Sp
Return an entry from the BHK structure.  \f(CW\*(C`which\*(C'\fR is a preprocessor token
indicating which entry to return.  If the appropriate flag is not set
this will return \f(CW\*(C`NULL\*(C'\fR.  The type of the return value depends on which
entry you ask for.
.RS 4
.Sp
.Vb 1
\& void *  BhkENTRY(BHK *hk, token which)
.Ve
.RE
.RS 4
.RE
.ie n .IP """BhkFLAGS""" 4
.el .IP \f(CWBhkFLAGS\fR 4
.IX Xref "BhkFLAGS"
.IX Item "BhkFLAGS"
NOTE: \f(CW\*(C`BhkFLAGS\*(C'\fR is \fBexperimental\fR and may change or be
removed without notice.
.Sp
Return the BHK's flags.
.RS 4
.Sp
.Vb 1
\& U32  BhkFLAGS(BHK *hk)
.Ve
.RE
.RS 4
.RE
.ie n .IP """CALL_BLOCK_HOOKS""" 4
.el .IP \f(CWCALL_BLOCK_HOOKS\fR 4
.IX Xref "CALL_BLOCK_HOOKS"
.IX Item "CALL_BLOCK_HOOKS"
NOTE: \f(CW\*(C`CALL_BLOCK_HOOKS\*(C'\fR is \fBexperimental\fR and may change or be
removed without notice.
.Sp
Call all the registered block hooks for type \f(CW\*(C`which\*(C'\fR.  \f(CW\*(C`which\*(C'\fR is a
preprocessing token; the type of \f(CW\*(C`arg\*(C'\fR depends on \f(CW\*(C`which\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& void  CALL_BLOCK_HOOKS(token which, arg)
.Ve
.RE
.RS 4
.RE
.SH Concurrency
.IX Header "Concurrency"
.ie n .IP """CVf_SLABBED""" 4
.el .IP \f(CWCVf_SLABBED\fR 4
.IX Item "CVf_SLABBED"
.PD 0
.ie n .IP """CvROOT""" 4
.el .IP \f(CWCvROOT\fR 4
.IX Item "CvROOT"
.ie n .IP """CvSTART""" 4
.el .IP \f(CWCvSTART\fR 4
.IX Item "CvSTART"
.PD
Described in perlguts.
.ie n .IP """CX_CUR""" 4
.el .IP \f(CWCX_CUR\fR 4
.IX Item "CX_CUR"
Described in perlguts.
.RS 4
.Sp
.Vb 1
\&   CX_CUR()
.Ve
.RE
.RS 4
.RE
.ie n .IP """CXINC""" 4
.el .IP \f(CWCXINC\fR 4
.IX Item "CXINC"
Described in perlguts.
.ie n .IP """CX_LEAVE_SCOPE""" 4
.el .IP \f(CWCX_LEAVE_SCOPE\fR 4
.IX Item "CX_LEAVE_SCOPE"
Described in perlguts.
.RS 4
.Sp
.Vb 1
\& void  CX_LEAVE_SCOPE(PERL_CONTEXT* cx)
.Ve
.RE
.RS 4
.RE
.ie n .IP """CX_POP""" 4
.el .IP \f(CWCX_POP\fR 4
.IX Item "CX_POP"
Described in perlguts.
.RS 4
.Sp
.Vb 1
\& void  CX_POP(PERL_CONTEXT* cx)
.Ve
.RE
.RS 4
.RE
.ie n .IP """cxstack""" 4
.el .IP \f(CWcxstack\fR 4
.IX Item "cxstack"
Described in perlguts.
.ie n .IP """cxstack_ix""" 4
.el .IP \f(CWcxstack_ix\fR 4
.IX Item "cxstack_ix"
Described in perlguts.
.ie n .IP """CXt_BLOCK""" 4
.el .IP \f(CWCXt_BLOCK\fR 4
.IX Item "CXt_BLOCK"
.PD 0
.ie n .IP """CXt_EVAL""" 4
.el .IP \f(CWCXt_EVAL\fR 4
.IX Item "CXt_EVAL"
.ie n .IP """CXt_FORMAT""" 4
.el .IP \f(CWCXt_FORMAT\fR 4
.IX Item "CXt_FORMAT"
.ie n .IP """CXt_GIVEN""" 4
.el .IP \f(CWCXt_GIVEN\fR 4
.IX Item "CXt_GIVEN"
.ie n .IP """CXt_LOOP_ARY""" 4
.el .IP \f(CWCXt_LOOP_ARY\fR 4
.IX Item "CXt_LOOP_ARY"
.ie n .IP """CXt_LOOP_LAZYIV""" 4
.el .IP \f(CWCXt_LOOP_LAZYIV\fR 4
.IX Item "CXt_LOOP_LAZYIV"
.ie n .IP """CXt_LOOP_LAZYSV""" 4
.el .IP \f(CWCXt_LOOP_LAZYSV\fR 4
.IX Item "CXt_LOOP_LAZYSV"
.ie n .IP """CXt_LOOP_LIST""" 4
.el .IP \f(CWCXt_LOOP_LIST\fR 4
.IX Item "CXt_LOOP_LIST"
.ie n .IP """CXt_LOOP_PLAIN""" 4
.el .IP \f(CWCXt_LOOP_PLAIN\fR 4
.IX Item "CXt_LOOP_PLAIN"
.ie n .IP """CXt_NULL""" 4
.el .IP \f(CWCXt_NULL\fR 4
.IX Item "CXt_NULL"
.ie n .IP """CXt_SUB""" 4
.el .IP \f(CWCXt_SUB\fR 4
.IX Item "CXt_SUB"
.ie n .IP """CXt_SUBST""" 4
.el .IP \f(CWCXt_SUBST\fR 4
.IX Item "CXt_SUBST"
.ie n .IP """CXt_WHEN""" 4
.el .IP \f(CWCXt_WHEN\fR 4
.IX Item "CXt_WHEN"
.PD
Described in perlguts.
.ie n .IP """cx_type""" 4
.el .IP \f(CWcx_type\fR 4
.IX Item "cx_type"
Described in perlguts.
.ie n .IP """dounwind""" 4
.el .IP \f(CWdounwind\fR 4
.IX Item "dounwind"
Described in perlguts.
.RS 4
.Sp
.Vb 1
\& void  dounwind(I32 cxix)
.Ve
.RE
.RS 4
.RE
.ie n .IP """my_fork""" 4
.el .IP \f(CWmy_fork\fR 4
.IX Xref "my_fork"
.IX Item "my_fork"
This is for the use of \f(CW\*(C`PerlProc_fork\*(C'\fR as a wrapper for the C library
\&\fBfork\fR\|(2) on some platforms to hide some platform quirks.  It should not be
used except through \f(CW\*(C`PerlProc_fork\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& Pid_t  my_fork()
.Ve
.RE
.RS 4
.RE
.ie n .IP """PERL_CONTEXT""" 4
.el .IP \f(CWPERL_CONTEXT\fR 4
.IX Item "PERL_CONTEXT"
Described in perlguts.
.SH "COPs and Hint Hashes"
.IX Header "COPs and Hint Hashes"
There are currently no internal API items in COPs and Hint Hashes
.SH "Custom Operators"
.IX Header "Custom Operators"
.ie n .IP """core_prototype""" 4
.el .IP \f(CWcore_prototype\fR 4
.IX Xref "core_prototype"
.IX Item "core_prototype"
This function assigns the prototype of the named core function to \f(CW\*(C`sv\*(C'\fR, or
to a new mortal SV if \f(CW\*(C`sv\*(C'\fR is \f(CW\*(C`NULL\*(C'\fR.  It returns the modified \f(CW\*(C`sv\*(C'\fR, or
\&\f(CW\*(C`NULL\*(C'\fR if the core function has no prototype.  \f(CW\*(C`code\*(C'\fR is a code as returned
by \f(CWkeyword()\fR.  It must not be equal to 0.
.RS 4
.Sp
.Vb 2
\& SV *  core_prototype(SV *sv, const char *name, const int code,
\&                      int * const opnum)
.Ve
.RE
.RS 4
.RE
.SH "CV Handling"
.IX Header "CV Handling"
.ie n .IP """CvREFCOUNTED_ANYSV""" 4
.el .IP \f(CWCvREFCOUNTED_ANYSV\fR 4
.IX Xref "CvREFCOUNTED_ANYSV"
.IX Item "CvREFCOUNTED_ANYSV"
If true, indicates that the \f(CW\*(C`CvXSUBANY(cv).any_sv\*(C'\fR member contains an SV
pointer whose reference count should be decremented when the CV itself is
freed.  In addition, \f(CWcv_clone()\fR will increment the reference count, and
\&\f(CWsv_dup()\fR will duplicate the entire pointed-to SV if this flag is set.
.Sp
Any CV that wraps an XSUB has an \f(CW\*(C`ANY\*(C'\fR union that the XSUB function is free
to use for its own purposes.  It may be the case that the code wishes to store
an SV in the \f(CW\*(C`any_sv\*(C'\fR member of this union.  By setting this flag, this SV
reference will be properly reclaimed or duplicated when the CV itself is.
.RS 4
.Sp
.Vb 1
\& bool  CvREFCOUNTED_ANYSV(CV *cv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """CvREFCOUNTED_ANYSV_off""" 4
.el .IP \f(CWCvREFCOUNTED_ANYSV_off\fR 4
.IX Xref "CvREFCOUNTED_ANYSV_off"
.IX Item "CvREFCOUNTED_ANYSV_off"
Helper macro to turn off the \f(CW\*(C`CvREFCOUNTED_ANYSV\*(C'\fR flag.
.RS 4
.Sp
.Vb 1
\& void  CvREFCOUNTED_ANYSV_off(CV *cv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """CvREFCOUNTED_ANYSV_on""" 4
.el .IP \f(CWCvREFCOUNTED_ANYSV_on\fR 4
.IX Xref "CvREFCOUNTED_ANYSV_on"
.IX Item "CvREFCOUNTED_ANYSV_on"
Helper macro to turn on the \f(CW\*(C`CvREFCOUNTED_ANYSV\*(C'\fR flag.
.RS 4
.Sp
.Vb 1
\& void  CvREFCOUNTED_ANYSV_on(CV *cv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """CvWEAKOUTSIDE""" 4
.el .IP \f(CWCvWEAKOUTSIDE\fR 4
.IX Xref "CvWEAKOUTSIDE"
.IX Item "CvWEAKOUTSIDE"
Each CV has a pointer, \f(CWCvOUTSIDE()\fR, to its lexically enclosing
CV (if any).  Because pointers to anonymous sub prototypes are
stored in \f(CW\*(C`&\*(C'\fR pad slots, it is a possible to get a circular reference,
with the parent pointing to the child and vice-versa.  To avoid the
ensuing memory leak, we do not increment the reference count of the CV
pointed to by \f(CW\*(C`CvOUTSIDE\*(C'\fR in the \fIone specific instance\fR that the parent
has a \f(CW\*(C`&\*(C'\fR pad slot pointing back to us.  In this case, we set the
\&\f(CW\*(C`CvWEAKOUTSIDE\*(C'\fR flag in the child.  This allows us to determine under what
circumstances we should decrement the refcount of the parent when freeing
the child.
.Sp
There is a further complication with non-closure anonymous subs (i.e. those
that do not refer to any lexicals outside that sub).  In this case, the
anonymous prototype is shared rather than being cloned.  This has the
consequence that the parent may be freed while there are still active
children, \fIe.g.\fR,
.Sp
.Vb 1
\&    BEGIN { $a = sub { eval \*(Aq$x\*(Aq } }
.Ve
.Sp
In this case, the BEGIN is freed immediately after execution since there
are no active references to it: the anon sub prototype has
\&\f(CW\*(C`CvWEAKOUTSIDE\*(C'\fR set since it's not a closure, and \f(CW$a\fR points to the same
CV, so it doesn't contribute to BEGIN's refcount either.  When \f(CW$a\fR is
executed, the \f(CW\*(C`eval \*(Aq$x\*(Aq\*(C'\fR causes the chain of \f(CW\*(C`CvOUTSIDE\*(C'\fRs to be followed,
and the freed BEGIN is accessed.
.Sp
To avoid this, whenever a CV and its associated pad is freed, any
\&\f(CW\*(C`&\*(C'\fR entries in the pad are explicitly removed from the pad, and if the
refcount of the pointed-to anon sub is still positive, then that
child's \f(CW\*(C`CvOUTSIDE\*(C'\fR is set to point to its grandparent.  This will only
occur in the single specific case of a non-closure anon prototype
having one or more active references (such as \f(CW$a\fR above).
.Sp
One other thing to consider is that a CV may be merely undefined
rather than freed, eg \f(CW\*(C`undef &foo\*(C'\fR.  In this case, its refcount may
not have reached zero, but we still delete its pad and its \f(CW\*(C`CvROOT\*(C'\fR etc.
Since various children may still have their \f(CW\*(C`CvOUTSIDE\*(C'\fR pointing at this
undefined CV, we keep its own \f(CW\*(C`CvOUTSIDE\*(C'\fR for the time being, so that
the chain of lexical scopes is unbroken.  For example, the following
should print 123:
.Sp
.Vb 5
\&    my $x = 123;
\&    sub tmp { sub { eval \*(Aq$x\*(Aq } }
\&    my $a = tmp();
\&    undef &tmp;
\&    print  $a\->();
.Ve
.RS 4
.Sp
.Vb 1
\& bool  CvWEAKOUTSIDE(CV *cv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """docatch""" 4
.el .IP \f(CWdocatch\fR 4
.IX Xref "docatch"
.IX Item "docatch"
Interpose, for the current op and RUNOPS loop,
.Sp
.Vb 3
\&    \- a new JMPENV stack catch frame, and
\&    \- an inner RUNOPS loop to run all the remaining ops following the
\&      current PL_op.
.Ve
.Sp
Then handle any exceptions raised while in that loop.
For a caught eval at this level, re-enter the loop with the specified
restart op (i.e. the op following the OP_LEAVETRY etc); otherwise re-throw
the exception.
.Sp
\&\fBdocatch()\fR is intended to be used like this:
.Sp
.Vb 4
\&    PP(pp_entertry)
\&    {
\&        if (CATCH_GET)
\&            return docatch(Perl_pp_entertry);
\&
\&        ... rest of function ...
\&        return PL_op\->op_next;
\&    }
.Ve
.Sp
If a new catch frame isn't needed, the op behaves normally. Otherwise it
calls \fBdocatch()\fR, which recursively calls \fBpp_entertry()\fR, this time with
\&\fBCATCH_GET()\fR false, so the rest of the body of the entertry is run. Then
\&\fBdocatch()\fR calls \fBCALLRUNOPS()\fR which executes all the ops following the
entertry. When the loop finally finishes, control returns to \fBdocatch()\fR,
which pops the JMPENV and returns to the parent \fBpp_entertry()\fR, which
itself immediately returns. Note that *all* subsequent ops are run within
the inner RUNOPS loop, not just the body of the eval. For example, in
.Sp
.Vb 2
\&    sub TIEARRAY { eval {1}; my $x }
\&    tie @a, "main";
.Ve
.Sp
at the point the 'my' is executed, the C stack will look something like:
.Sp
.Vb 11
\&    #10 main()
\&    #9  perl_run()              # JMPENV_PUSH level 1 here
\&    #8  S_run_body()
\&    #7  Perl_runops_standard()  # main RUNOPS loop
\&    #6  Perl_pp_tie()
\&    #5  Perl_call_sv()
\&    #4  Perl_runops_standard()  # unguarded RUNOPS loop: no new JMPENV
\&    #3  Perl_pp_entertry()
\&    #2  S_docatch()             # JMPENV_PUSH level 2 here
\&    #1  Perl_runops_standard()  # docatch()\*(Aqs RUNOPs loop
\&    #0  Perl_pp_padsv()
.Ve
.Sp
Basically, any section of the perl core which starts a RUNOPS loop may
make a promise that it will catch any exceptions and restart the loop if
necessary. If it's not prepared to do that (like \fBcall_sv()\fR isn't), then
it sets \fBCATCH_GET()\fR to true, so that any later eval-like code knows to
set up a new handler and loop (via \fBdocatch()\fR).
.Sp
See "Exception handing" in perlinterp for further details.
.RS 4
.Sp
.Vb 1
\& OP *  docatch(Perl_ppaddr_t firstpp)
.Ve
.RE
.RS 4
.RE
.SH Debugging
.IX Header "Debugging"
.ie n .IP """comma_aDEPTH""" 4
.el .IP \f(CWcomma_aDEPTH\fR 4
.IX Xref "comma_aDEPTH"
.IX Item "comma_aDEPTH"
Some functions when compiled under DEBUGGING take an extra final argument named
\&\f(CW\*(C`depth\*(C'\fR, indicating the C stack depth.  This argument is omitted otherwise.
This macro expands to either \f(CW\*(C`,\ depth\*(C'\fR under DEBUGGING, or to nothing at
all when not under DEBUGGING, reducing the number of \f(CW\*(C`#ifdef\*(C'\fR's in the code.
.Sp
The program is responsible for maintaining the correct value for \f(CW\*(C`depth\*(C'\fR.
.RS 4
.Sp
.Vb 1
\&   comma_aDEPTH
.Ve
.RE
.RS 4
.RE
.ie n .IP """comma_pDEPTH""" 4
.el .IP \f(CWcomma_pDEPTH\fR 4
.IX Xref "comma_pDEPTH"
.IX Item "comma_pDEPTH"
This is used in the prototype declarations for functions that take a "\f(CW\*(C`comma_aDEPTH\*(C'\fR"
final parameter, much like \f(CW\*(C`pTHX_\*(C'\fR
is used in functions that take a thread context initial parameter.
.ie n .IP """debop""" 4
.el .IP \f(CWdebop\fR 4
.IX Xref "debop"
.IX Item "debop"
Implements \fB\-Dt\fR perl command line option on OP \f(CW\*(C`o\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& I32  debop(const OP *o)
.Ve
.RE
.RS 4
.RE
.ie n .IP """debprof""" 4
.el .IP \f(CWdebprof\fR 4
.IX Xref "debprof"
.IX Item "debprof"
Called to indicate that \f(CW\*(C`o\*(C'\fR was executed, for profiling purposes under the
\&\f(CW\*(C`\-DP\*(C'\fR command line option.
.RS 4
.Sp
.Vb 1
\& void  debprof(const OP *o)
.Ve
.RE
.RS 4
.RE
.ie n .IP """debprofdump""" 4
.el .IP \f(CWdebprofdump\fR 4
.IX Xref "debprofdump"
.IX Item "debprofdump"
Dumps the contents of the data collected by the \f(CW\*(C`\-DP\*(C'\fR perl command line
option.
.RS 4
.Sp
.Vb 1
\& void  debprofdump()
.Ve
.RE
.RS 4
.RE
.ie n .IP """debug_aDEPTH""" 4
.el .IP \f(CWdebug_aDEPTH\fR 4
.IX Xref "debug_aDEPTH"
.IX Item "debug_aDEPTH"
Same as "\f(CW\*(C`comma_aDEPTH\*(C'\fR" but with no leading argument. Intended for functions with
no normal arguments, and used by "\f(CW\*(C`comma_aDEPTH\*(C'\fR" itself.
.RS 4
.Sp
.Vb 1
\&   debug_aDEPTH
.Ve
.RE
.RS 4
.RE
.ie n .IP """debug_pDEPTH""" 4
.el .IP \f(CWdebug_pDEPTH\fR 4
.IX Xref "debug_pDEPTH"
.IX Item "debug_pDEPTH"
Same as "\f(CW\*(C`comma_pDEPTH\*(C'\fR" but with no leading argument. Intended for functions with
no normal arguments, and used by "\f(CW\*(C`comma_pDEPTH\*(C'\fR" itself.
.RS 4
.Sp
.Vb 1
\&   debug_pDEPTH
.Ve
.RE
.RS 4
.RE
.ie n .IP """free_c_backtrace""" 4
.el .IP \f(CWfree_c_backtrace\fR 4
.IX Xref "free_c_backtrace"
.IX Item "free_c_backtrace"
Deallocates a backtrace received from get_c_backtrace.
.RS 4
.Sp
.Vb 1
\& void  free_c_backtrace(Perl_c_backtrace *bt)
.Ve
.RE
.RS 4
.RE
.ie n .IP """get_c_backtrace""" 4
.el .IP \f(CWget_c_backtrace\fR 4
.IX Xref "get_c_backtrace"
.IX Item "get_c_backtrace"
Collects the backtrace (aka "stacktrace") into a single linear
malloced buffer, which the caller \fBmust\fR \f(CWPerl_free_c_backtrace()\fR.
.Sp
Scans the frames back by \f(CW\*(C`depth\ +\ skip\*(C'\fR, then drops the \f(CW\*(C`skip\*(C'\fR innermost,
returning at most \f(CW\*(C`depth\*(C'\fR frames.
.RS 4
.Sp
.Vb 1
\& Perl_c_backtrace *  get_c_backtrace(int max_depth, int skip)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PL_DBsingle""" 4
.el .IP \f(CWPL_DBsingle\fR 4
.IX Xref "PL_DBsingle"
.IX Item "PL_DBsingle"
When Perl is run in debugging mode, with the \fB\-d\fR switch, this SV is a
boolean which indicates whether subs are being single-stepped.
Single-stepping is automatically turned on after every step.  This is the C
variable which corresponds to Perl's \f(CW$DB::single\fR variable.  See
\&\f(CW"PL_DBsub"\fR.
.Sp
On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.
.RS 4
.Sp
.Vb 1
\& SV *  PL_DBsingle
.Ve
.RE
.RS 4
.RE
.ie n .IP """PL_DBsub""" 4
.el .IP \f(CWPL_DBsub\fR 4
.IX Xref "PL_DBsub"
.IX Item "PL_DBsub"
When Perl is run in debugging mode, with the \fB\-d\fR switch, this GV contains
the SV which holds the name of the sub being debugged.  This is the C
variable which corresponds to Perl's \f(CW$DB::sub\fR variable.  See
\&\f(CW"PL_DBsingle"\fR.
.Sp
On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.
.RS 4
.Sp
.Vb 1
\& GV *  PL_DBsub
.Ve
.RE
.RS 4
.RE
.ie n .IP """PL_DBtrace""" 4
.el .IP \f(CWPL_DBtrace\fR 4
.IX Xref "PL_DBtrace"
.IX Item "PL_DBtrace"
Trace variable used when Perl is run in debugging mode, with the \fB\-d\fR
switch.  This is the C variable which corresponds to Perl's \f(CW$DB::trace\fR
variable.  See \f(CW"PL_DBsingle"\fR.
.Sp
On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.
.RS 4
.Sp
.Vb 1
\& SV *  PL_DBtrace
.Ve
.RE
.RS 4
.RE
.ie n .IP """runops_debug""" 4
.el .IP \f(CWrunops_debug\fR 4
.IX Item "runops_debug"
Described in perlguts.
.RS 4
.Sp
.Vb 1
\& int  runops_debug()
.Ve
.RE
.RS 4
.RE
.ie n .IP """runops_standard""" 4
.el .IP \f(CWrunops_standard\fR 4
.IX Item "runops_standard"
Described in perlguts.
.RS 4
.Sp
.Vb 1
\& int  runops_standard()
.Ve
.RE
.RS 4
.RE
.SH "Display functions"
.IX Xref "PERL_PV_PRETTY_DUMP PERL_PV_PRETTY_NOCLEAR PERL_PV_PRETTY_REGPROP"
.IX Header "Display functions"
.ie n .IP """sv_peek""" 4
.el .IP \f(CWsv_peek\fR 4
.IX Xref "sv_peek"
.IX Item "sv_peek"
Implements \f(CW\*(C`SvPEEK\*(C'\fR
.RS 4
.Sp
.Vb 1
\& char *  sv_peek(SV *sv)
.Ve
.RE
.RS 4
.RE
.SH "Embedding, Threads, and Interpreter Cloning"
.IX Header "Embedding, Threads, and Interpreter Cloning"
.ie n .IP """cv_dump""" 4
.el .IP \f(CWcv_dump\fR 4
.IX Xref "cv_dump"
.IX Item "cv_dump"
dump the contents of a CV
.RS 4
.Sp
.Vb 1
\& void  cv_dump(const CV *cv, const char *title)
.Ve
.RE
.RS 4
.RE
.ie n .IP """cv_forget_slab""" 4
.el .IP \f(CWcv_forget_slab\fR 4
.IX Xref "cv_forget_slab"
.IX Item "cv_forget_slab"
When a CV has a reference count on its slab (\f(CW\*(C`CvSLABBED\*(C'\fR), it is responsible
for making sure it is freed.  (Hence, no two CVs should ever have a
reference count on the same slab.)  The CV only needs to reference the slab
during compilation.  Once it is compiled and \f(CW\*(C`CvROOT\*(C'\fR attached, it has
finished its job, so it can forget the slab.
.RS 4
.Sp
.Vb 1
\& void  cv_forget_slab(CV *cv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """do_dump_pad""" 4
.el .IP \f(CWdo_dump_pad\fR 4
.IX Xref "do_dump_pad"
.IX Item "do_dump_pad"
Dump the contents of a padlist
.RS 4
.Sp
.Vb 2
\& void  do_dump_pad(I32 level, PerlIO *file, PADLIST *padlist,
\&                   int full)
.Ve
.RE
.RS 4
.RE
.ie n .IP """get_context""" 4
.el .IP \f(CWget_context\fR 4
.IX Xref "get_context"
.IX Item "get_context"
Implements "\f(CW\*(C`PERL_GET_CONTEXT\*(C'\fR" in perlapi, which you should use instead.
.RS 4
.Sp
.Vb 1
\& void *  get_context()
.Ve
.RE
.RS 4
.RE
.ie n .IP """pad_alloc_name""" 4
.el .IP \f(CWpad_alloc_name\fR 4
.IX Xref "pad_alloc_name"
.IX Item "pad_alloc_name"
Allocates a place in the currently-compiling
pad (via "pad_alloc" in perlapi) and
then stores a name for that entry.  \f(CW\*(C`name\*(C'\fR is adopted and
becomes the name entry; it must already contain the name
string.  \f(CW\*(C`typestash\*(C'\fR and \f(CW\*(C`ourstash\*(C'\fR and the \f(CW\*(C`padadd_STATE\*(C'\fR
flag gets added to \f(CW\*(C`name\*(C'\fR.
None of the other processing of "pad_add_name_pvn" in perlapi
is done.  Returns the offset of the allocated pad slot.
.RS 4
.Sp
.Vb 2
\& PADOFFSET  pad_alloc_name(PADNAME *name, U32 flags, HV *typestash,
\&                           HV *ourstash)
.Ve
.RE
.RS 4
.RE
.ie n .IP """pad_block_start""" 4
.el .IP \f(CWpad_block_start\fR 4
.IX Xref "pad_block_start"
.IX Item "pad_block_start"
Update the pad compilation state variables on entry to a new block.
.RS 4
.Sp
.Vb 1
\& void  pad_block_start(int full)
.Ve
.RE
.RS 4
.RE
.ie n .IP """pad_check_dup""" 4
.el .IP \f(CWpad_check_dup\fR 4
.IX Xref "pad_check_dup"
.IX Item "pad_check_dup"
Check for duplicate declarations: report any of:
.Sp
.Vb 3
\&     * a \*(Aqmy\*(Aq in the current scope with the same name;
\&     * an \*(Aqour\*(Aq (anywhere in the pad) with the same name and the
\&       same stash as \*(Aqourstash\*(Aq
.Ve
.Sp
\&\f(CW\*(C`is_our\*(C'\fR indicates that the name to check is an \f(CW"our"\fR declaration.
.RS 4
.Sp
.Vb 1
\& void  pad_check_dup(PADNAME *name, U32 flags, const HV *ourstash)
.Ve
.RE
.RS 4
.RE
.ie n .IP """pad_findlex""" 4
.el .IP \f(CWpad_findlex\fR 4
.IX Xref "pad_findlex"
.IX Item "pad_findlex"
Find a named lexical anywhere in a chain of nested pads.  Add fake entries
in the inner pads if it's found in an outer one.
.Sp
Returns the offset in the bottom pad of the lex or the fake lex.
\&\f(CW\*(C`cv\*(C'\fR is the CV in which to start the search, and seq is the current \f(CW\*(C`cop_seq\*(C'\fR
to match against.  If \f(CW\*(C`warn\*(C'\fR is true, print appropriate warnings.  The \f(CW\*(C`out_\*(C'\fR*
vars return values, and so are pointers to where the returned values
should be stored.  \f(CW\*(C`out_capture\*(C'\fR, if non-null, requests that the innermost
instance of the lexical is captured; \f(CW\*(C`out_name\*(C'\fR is set to the innermost
matched pad name or fake pad name; \f(CW\*(C`out_flags\*(C'\fR returns the flags normally
associated with the \f(CW\*(C`PARENT_FAKELEX_FLAGS\*(C'\fR field of a fake pad name.
.Sp
Note that \f(CWpad_findlex()\fR is recursive; it recurses up the chain of CVs,
then comes back down, adding fake entries
as it goes.  It has to be this way
because fake names in anon prototypes have to store in \f(CW\*(C`xpadn_low\*(C'\fR the
index into the parent pad.
.RS 4
.Sp
.Vb 4
\& PADOFFSET  pad_findlex(const char *namepv, STRLEN namelen,
\&                        U32 flags, const CV *cv, U32 seq, int warn,
\&                        SV **out_capture, PADNAME **out_name,
\&                        int *out_flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """pad_fixup_inner_anons""" 4
.el .IP \f(CWpad_fixup_inner_anons\fR 4
.IX Xref "pad_fixup_inner_anons"
.IX Item "pad_fixup_inner_anons"
For any anon CVs in the pad, change \f(CW\*(C`CvOUTSIDE\*(C'\fR of that CV from
\&\f(CW\*(C`old_cv\*(C'\fR to \f(CW\*(C`new_cv\*(C'\fR if necessary.  Needed when a newly-compiled CV has to be
moved to a pre-existing CV struct.
.RS 4
.Sp
.Vb 2
\& void  pad_fixup_inner_anons(PADLIST *padlist, CV *old_cv,
\&                             CV *new_cv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """pad_free""" 4
.el .IP \f(CWpad_free\fR 4
.IX Xref "pad_free"
.IX Item "pad_free"
Free the SV at offset po in the current pad.
.RS 4
.Sp
.Vb 1
\& void  pad_free(PADOFFSET po)
.Ve
.RE
.RS 4
.RE
.ie n .IP """pad_leavemy""" 4
.el .IP \f(CWpad_leavemy\fR 4
.IX Xref "pad_leavemy"
.IX Item "pad_leavemy"
Cleanup at end of scope during compilation: set the max seq number for
lexicals in this scope and warn of any lexicals that never got introduced.
.RS 4
.Sp
.Vb 1
\& OP *  pad_leavemy()
.Ve
.RE
.RS 4
.RE
.ie n .IP """padlist_dup""" 4
.el .IP \f(CWpadlist_dup\fR 4
.IX Xref "padlist_dup"
.IX Item "padlist_dup"
Duplicates a pad.
.RS 4
.Sp
.Vb 1
\& PADLIST *  padlist_dup(PADLIST *srcpad, CLONE_PARAMS *param)
.Ve
.RE
.RS 4
.RE
.ie n .IP """padname_dup""" 4
.el .IP \f(CWpadname_dup\fR 4
.IX Xref "padname_dup"
.IX Item "padname_dup"
Duplicates a pad name.
.RS 4
.Sp
.Vb 1
\& PADNAME *  padname_dup(PADNAME *src, CLONE_PARAMS *param)
.Ve
.RE
.RS 4
.RE
.ie n .IP """padnamelist_dup""" 4
.el .IP \f(CWpadnamelist_dup\fR 4
.IX Xref "padnamelist_dup"
.IX Item "padnamelist_dup"
Duplicates a pad name list.
.RS 4
.Sp
.Vb 2
\& PADNAMELIST *  padnamelist_dup(PADNAMELIST *srcpad,
\&                                CLONE_PARAMS *param)
.Ve
.RE
.RS 4
.RE
.ie n .IP """pad_push""" 4
.el .IP \f(CWpad_push\fR 4
.IX Xref "pad_push"
.IX Item "pad_push"
Push a new pad frame onto the padlist, unless there's already a pad at
this depth, in which case don't bother creating a new one.  Then give
the new pad an \f(CW@_\fR in slot zero.
.RS 4
.Sp
.Vb 1
\& void  pad_push(PADLIST *padlist, int depth)
.Ve
.RE
.RS 4
.RE
.ie n .IP """pad_reset""" 4
.el .IP \f(CWpad_reset\fR 4
.IX Xref "pad_reset"
.IX Item "pad_reset"
Mark all the current temporaries for reuse
.RS 4
.Sp
.Vb 1
\& void  pad_reset()
.Ve
.RE
.RS 4
.RE
.ie n .IP """pad_setsv""" 4
.el .IP \f(CWpad_setsv\fR 4
.IX Xref "pad_setsv"
.IX Item "pad_setsv"
Set the value at offset \f(CW\*(C`po\*(C'\fR in the current (compiling or executing) pad.
Use the macro \f(CWPAD_SETSV()\fR rather than calling this function directly.
.RS 4
.Sp
.Vb 1
\& void  pad_setsv(PADOFFSET po, SV *sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """pad_sv""" 4
.el .IP \f(CWpad_sv\fR 4
.IX Xref "pad_sv"
.IX Item "pad_sv"
Get the value at offset \f(CW\*(C`po\*(C'\fR in the current (compiling or executing) pad.
Use macro \f(CW\*(C`PAD_SV\*(C'\fR instead of calling this function directly.
.RS 4
.Sp
.Vb 1
\& SV *  pad_sv(PADOFFSET po)
.Ve
.RE
.RS 4
.RE
.ie n .IP """pad_swipe""" 4
.el .IP \f(CWpad_swipe\fR 4
.IX Xref "pad_swipe"
.IX Item "pad_swipe"
Abandon the tmp in the current pad at offset \f(CW\*(C`po\*(C'\fR and replace with a
new one.
.RS 4
.Sp
.Vb 1
\& void  pad_swipe(PADOFFSET po, bool refadjust)
.Ve
.RE
.RS 4
.RE
.ie n .IP """set_context""" 4
.el .IP \f(CWset_context\fR 4
.IX Xref "set_context"
.IX Item "set_context"
Implements "\f(CW\*(C`PERL_SET_CONTEXT\*(C'\fR" in perlapi, which you should use instead.
.RS 4
.Sp
.Vb 1
\& void  set_context(void *t)
.Ve
.RE
.RS 4
.RE
.ie n .IP """si_dup""" 4
.el .IP \f(CWsi_dup\fR 4
.IX Xref "si_dup"
.IX Item "si_dup"
Duplicate a stack info structure, returning a pointer to the cloned object.
.RS 4
.Sp
.Vb 1
\& PERL_SI *  si_dup(PERL_SI *si, CLONE_PARAMS *param)
.Ve
.RE
.RS 4
.RE
.ie n .IP """ss_dup""" 4
.el .IP \f(CWss_dup\fR 4
.IX Xref "ss_dup"
.IX Item "ss_dup"
Duplicate the save stack, returning a pointer to the cloned object.
.RS 4
.Sp
.Vb 1
\& ANY *  ss_dup(PerlInterpreter *proto_perl, CLONE_PARAMS *param)
.Ve
.RE
.RS 4
.RE
.SH Errno
.IX Header "Errno"
.ie n .IP """dSAVEDERRNO""" 4
.el .IP \f(CWdSAVEDERRNO\fR 4
.IX Xref "dSAVEDERRNO"
.IX Item "dSAVEDERRNO"
Declare variables needed to save \f(CW\*(C`errno\*(C'\fR and any operating system
specific error number.
.RS 4
.Sp
.Vb 1
\& void  dSAVEDERRNO
.Ve
.RE
.RS 4
.RE
.ie n .IP """dSAVE_ERRNO""" 4
.el .IP \f(CWdSAVE_ERRNO\fR 4
.IX Xref "dSAVE_ERRNO"
.IX Item "dSAVE_ERRNO"
Declare variables needed to save \f(CW\*(C`errno\*(C'\fR and any operating system
specific error number, and save them for optional later restoration
by \f(CW\*(C`RESTORE_ERRNO\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& void  dSAVE_ERRNO
.Ve
.RE
.RS 4
.RE
.ie n .IP """RESTORE_ERRNO""" 4
.el .IP \f(CWRESTORE_ERRNO\fR 4
.IX Xref "RESTORE_ERRNO"
.IX Item "RESTORE_ERRNO"
Restore \f(CW\*(C`errno\*(C'\fR and any operating system specific error number that
was saved by \f(CW\*(C`dSAVE_ERRNO\*(C'\fR or \f(CW\*(C`RESTORE_ERRNO\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& void  RESTORE_ERRNO
.Ve
.RE
.RS 4
.RE
.ie n .IP """SAVE_ERRNO""" 4
.el .IP \f(CWSAVE_ERRNO\fR 4
.IX Xref "SAVE_ERRNO"
.IX Item "SAVE_ERRNO"
Save \f(CW\*(C`errno\*(C'\fR and any operating system specific error number for
optional later restoration by \f(CW\*(C`RESTORE_ERRNO\*(C'\fR.  Requires
\&\f(CW\*(C`dSAVEDERRNO\*(C'\fR or \f(CW\*(C`dSAVE_ERRNO\*(C'\fR in scope.
.RS 4
.Sp
.Vb 1
\& void  SAVE_ERRNO
.Ve
.RE
.RS 4
.RE
.ie n .IP """SETERRNO""" 4
.el .IP \f(CWSETERRNO\fR 4
.IX Xref "SETERRNO"
.IX Item "SETERRNO"
Set \f(CW\*(C`errno\*(C'\fR, and on VMS set \f(CW\*(C`vaxc$errno\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& void  SETERRNO(int errcode, int vmserrcode)
.Ve
.RE
.RS 4
.RE
.SH "Exception Handling (simple) Macros"
.IX Header "Exception Handling (simple) Macros"
There are currently no internal API items in Exception Handling (simple) Macros
.SH "Filesystem configuration values"
.IX Header "Filesystem configuration values"
There are currently no internal API items in Filesystem configuration values
.SH "Floating point"
.IX Header "Floating point"
There are currently no internal API items in Floating point
.SH "General Configuration"
.IX Header "General Configuration"
There are currently no internal API items in General Configuration
.SH "Global Variables"
.IX Header "Global Variables"
There are currently no internal API items in Global Variables
.SH "GV Handling and Stashes"
.IX Xref "GV_CACHE_ONLY"
.IX Header "GV Handling and Stashes"
.ie n .IP """amagic_applies""" 4
.el .IP \f(CWamagic_applies\fR 4
.IX Xref "amagic_applies"
.IX Item "amagic_applies"
Check \f(CW\*(C`sv\*(C'\fR to see if the overloaded (active magic) operation \f(CW\*(C`method\*(C'\fR
applies to it. If the sv is not SvROK or it is not an object then returns
false, otherwise checks if the object is blessed into a class supporting
overloaded operations, and returns true if a call to \fBamagic_call()\fR with
this SV and the given method would trigger an amagic operation, including
via the overload fallback rules or via nomethod. Thus a call like:
.Sp
.Vb 1
\&    amagic_applies(sv, string_amg, AMG_unary)
.Ve
.Sp
would return true for an object with overloading set up in any of the
following ways:
.Sp
.Vb 2
\&    use overload q("") => sub { ... };
\&    use overload q(0+) => sub { ... }, fallback => 1;
.Ve
.Sp
and could be used to tell if a given object would stringify to something
other than the normal default ref stringification.
.Sp
Note that the fact that this function returns TRUE does not mean you
can succesfully perform the operation with \fBamagic_call()\fR, for instance
any overloaded method might throw a fatal exception,  however if this
function returns FALSE you can be confident that it will NOT perform
the given overload operation.
.Sp
\&\f(CW\*(C`method\*(C'\fR is an integer enum, one of the values found in \fIoverload.h\fR,
for instance \f(CW\*(C`string_amg\*(C'\fR.
.Sp
\&\f(CW\*(C`flags\*(C'\fR should be set to AMG_unary for unary operations.
.RS 4
.Sp
.Vb 1
\& bool  amagic_applies(SV *sv, int method, int flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """gp_dup""" 4
.el .IP \f(CWgp_dup\fR 4
.IX Xref "gp_dup"
.IX Item "gp_dup"
Duplicate a typeglob, returning a pointer to the cloned object.
.RS 4
.Sp
.Vb 1
\& GP *  gp_dup(GP * const gp, CLONE_PARAMS * const param)
.Ve
.RE
.RS 4
.RE
.ie n .IP """gv_handler""" 4
.el .IP \f(CWgv_handler\fR 4
.IX Xref "gv_handler"
.IX Item "gv_handler"
Implements \f(CW\*(C`StashHANDLER\*(C'\fR, which you should use instead
.RS 4
.Sp
.Vb 1
\& CV *  gv_handler(HV *stash, I32 id)
.Ve
.RE
.RS 4
.RE
.ie n .IP """gv_stashsvpvn_cached""" 4
.el .IP \f(CWgv_stashsvpvn_cached\fR 4
.IX Xref "gv_stashsvpvn_cached"
.IX Item "gv_stashsvpvn_cached"
Returns a pointer to the stash for a specified package, possibly
cached.  Implements both "\f(CW\*(C`gv_stashpvn\*(C'\fR" in perlapi and
"\f(CW\*(C`gv_stashsv\*(C'\fR" in perlapi.
.Sp
Requires one of either \f(CW\*(C`namesv\*(C'\fR or \f(CW\*(C`namepv\*(C'\fR to be non-null.
.Sp
If the flag \f(CW\*(C`GV_CACHE_ONLY\*(C'\fR is set, return the stash only if found in the
cache; see "\f(CW\*(C`gv_stashpvn\*(C'\fR" in perlapi for details on the other \f(CW\*(C`flags\*(C'\fR.
.Sp
Note it is strongly preferred for \f(CW\*(C`namesv\*(C'\fR to be non-null, for performance
reasons.
.RS 4
.Sp
.Vb 2
\& HV *  gv_stashsvpvn_cached(SV *namesv, const char *name,
\&                            U32 namelen, I32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """gv_try_downgrade""" 4
.el .IP \f(CWgv_try_downgrade\fR 4
.IX Xref "gv_try_downgrade"
.IX Item "gv_try_downgrade"
NOTE: \f(CW\*(C`gv_try_downgrade\*(C'\fR is \fBexperimental\fR and may change or be
removed without notice.
.Sp
If the typeglob \f(CW\*(C`gv\*(C'\fR can be expressed more succinctly, by having
something other than a real GV in its place in the stash, replace it
with the optimised form.  Basic requirements for this are that \f(CW\*(C`gv\*(C'\fR
is a real typeglob, is sufficiently ordinary, and is only referenced
from its package.  This function is meant to be used when a GV has been
looked up in part to see what was there, causing upgrading, but based
on what was found it turns out that the real GV isn't required after all.
.Sp
If \f(CW\*(C`gv\*(C'\fR is a completely empty typeglob, it is deleted from the stash.
.Sp
If \f(CW\*(C`gv\*(C'\fR is a typeglob containing only a sufficiently-ordinary constant
sub, the typeglob is replaced with a scalar-reference placeholder that
more compactly represents the same thing.
.RS 4
.Sp
.Vb 1
\& void  gv_try_downgrade(GV *gv)
.Ve
.RE
.RS 4
.RE
.SH "Hook manipulation"
.IX Header "Hook manipulation"
There are currently no internal API items in Hook manipulation
.SH "HV Handling"
.IX Xref "HvNAME_get"
.IX Header "HV Handling"
.ie n .IP """hv_eiter_p""" 4
.el .IP \f(CWhv_eiter_p\fR 4
.IX Xref "hv_eiter_p"
.IX Item "hv_eiter_p"
Implements \f(CW\*(C`HvEITER\*(C'\fR which you should use instead.
.Sp
NOTE: \f(CW\*(C`hv_eiter_p\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_hv_eiter_p\*(C'\fR
with an \f(CW\*(C`aTHX_\*(C'\fR parameter.
.RS 4
.Sp
.Vb 1
\& HE **  Perl_hv_eiter_p(pTHX_ HV *hv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """hv_eiter_set""" 4
.el .IP \f(CWhv_eiter_set\fR 4
.IX Xref "hv_eiter_set"
.IX Item "hv_eiter_set"
Implements \f(CW\*(C`HvEITER_set\*(C'\fR which you should use instead.
.Sp
NOTE: \f(CW\*(C`hv_eiter_set\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_hv_eiter_set\*(C'\fR
with an \f(CW\*(C`aTHX_\*(C'\fR parameter.
.RS 4
.Sp
.Vb 1
\& void  Perl_hv_eiter_set(pTHX_ HV *hv, HE *eiter)
.Ve
.RE
.RS 4
.RE
.ie n .IP """hv_ename_add""" 4
.el .IP \f(CWhv_ename_add\fR 4
.IX Xref "hv_ename_add"
.IX Item "hv_ename_add"
Adds a name to a stash's internal list of effective names.  See
\&\f(CW"hv_ename_delete"\fR.
.Sp
This is called when a stash is assigned to a new location in the symbol
table.
.RS 4
.Sp
.Vb 1
\& void  hv_ename_add(HV *hv, const char *name, U32 len, U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """hv_ename_delete""" 4
.el .IP \f(CWhv_ename_delete\fR 4
.IX Xref "hv_ename_delete"
.IX Item "hv_ename_delete"
Removes a name from a stash's internal list of effective names.  If this is
the name returned by \f(CW\*(C`HvENAME\*(C'\fR, then another name in the list will take
its place (\f(CW\*(C`HvENAME\*(C'\fR will use it).
.Sp
This is called when a stash is deleted from the symbol table.
.RS 4
.Sp
.Vb 2
\& void  hv_ename_delete(HV *hv, const char *name, U32 len,
\&                       U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """hv_fill""" 4
.el .IP \f(CWhv_fill\fR 4
.IX Xref "hv_fill"
.IX Item "hv_fill"
Returns the number of hash buckets that happen to be in use.
.Sp
This function implements the \f(CW\*(C`HvFILL\*(C'\fR macro which you should
use instead.
.Sp
As of perl 5.25 this function is used only for debugging
purposes, and the number of used hash buckets is not
in any way cached, thus this function can be costly
to execute as it must iterate over all the buckets in the
hash.
.Sp
NOTE: \f(CW\*(C`hv_fill\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_hv_fill\*(C'\fR
with an \f(CW\*(C`aTHX_\*(C'\fR parameter.
.RS 4
.Sp
.Vb 1
\& STRLEN  Perl_hv_fill(pTHX_ HV * const hv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """hv_placeholders_get""" 4
.el .IP \f(CWhv_placeholders_get\fR 4
.IX Xref "hv_placeholders_get"
.IX Item "hv_placeholders_get"
Implements \f(CW\*(C`HvPLACEHOLDERS_get\*(C'\fR, which you should use instead.
.Sp
NOTE: \f(CW\*(C`hv_placeholders_get\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_hv_placeholders_get\*(C'\fR
with an \f(CW\*(C`aTHX_\*(C'\fR parameter.
.RS 4
.Sp
.Vb 1
\& I32  Perl_hv_placeholders_get(pTHX_ const HV *hv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """hv_placeholders_set""" 4
.el .IP \f(CWhv_placeholders_set\fR 4
.IX Xref "hv_placeholders_set"
.IX Item "hv_placeholders_set"
Implements \f(CW\*(C`HvPLACEHOLDERS_set\*(C'\fR, which you should use instead.
.Sp
NOTE: \f(CW\*(C`hv_placeholders_set\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_hv_placeholders_set\*(C'\fR
with an \f(CW\*(C`aTHX_\*(C'\fR parameter.
.RS 4
.Sp
.Vb 1
\& void  Perl_hv_placeholders_set(pTHX_ HV *hv, I32 ph)
.Ve
.RE
.RS 4
.RE
.ie n .IP """hv_riter_p""" 4
.el .IP \f(CWhv_riter_p\fR 4
.IX Xref "hv_riter_p"
.IX Item "hv_riter_p"
Implements \f(CW\*(C`HvRITER\*(C'\fR which you should use instead.
.Sp
NOTE: \f(CW\*(C`hv_riter_p\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_hv_riter_p\*(C'\fR
with an \f(CW\*(C`aTHX_\*(C'\fR parameter.
.RS 4
.Sp
.Vb 1
\& I32 *  Perl_hv_riter_p(pTHX_ HV *hv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """hv_riter_set""" 4
.el .IP \f(CWhv_riter_set\fR 4
.IX Xref "hv_riter_set"
.IX Item "hv_riter_set"
Implements \f(CW\*(C`HvRITER_set\*(C'\fR which you should use instead.
.Sp
NOTE: \f(CW\*(C`hv_riter_set\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_hv_riter_set\*(C'\fR
with an \f(CW\*(C`aTHX_\*(C'\fR parameter.
.RS 4
.Sp
.Vb 1
\& void  Perl_hv_riter_set(pTHX_ HV *hv, I32 riter)
.Ve
.RE
.RS 4
.RE
.ie n .IP """refcounted_he_chain_2hv""" 4
.el .IP \f(CWrefcounted_he_chain_2hv\fR 4
.IX Xref "refcounted_he_chain_2hv"
.IX Item "refcounted_he_chain_2hv"
Generates and returns a \f(CW\*(C`HV *\*(C'\fR representing the content of a
\&\f(CW\*(C`refcounted_he\*(C'\fR chain.
\&\f(CW\*(C`flags\*(C'\fR is currently unused and must be zero.
.RS 4
.Sp
.Vb 2
\& HV *  refcounted_he_chain_2hv(const struct refcounted_he *c,
\&                               U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """refcounted_he_fetch_pv""" 4
.el .IP \f(CWrefcounted_he_fetch_pv\fR 4
.IX Xref "refcounted_he_fetch_pv"
.IX Item "refcounted_he_fetch_pv"
Like "refcounted_he_fetch_pvn", but takes a nul-terminated string
instead of a string/length pair.
.RS 4
.Sp
.Vb 2
\& SV *  refcounted_he_fetch_pv(const struct refcounted_he *chain,
\&                              const char *key, U32 hash, U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """refcounted_he_fetch_pvn""" 4
.el .IP \f(CWrefcounted_he_fetch_pvn\fR 4
.IX Xref "refcounted_he_fetch_pvn"
.IX Item "refcounted_he_fetch_pvn"
Search along a \f(CW\*(C`refcounted_he\*(C'\fR chain for an entry with the key specified
by \f(CW\*(C`keypv\*(C'\fR and \f(CW\*(C`keylen\*(C'\fR.  If \f(CW\*(C`flags\*(C'\fR has the \f(CW\*(C`REFCOUNTED_HE_KEY_UTF8\*(C'\fR
bit set, the key octets are interpreted as UTF\-8, otherwise they
are interpreted as Latin\-1.  \f(CW\*(C`hash\*(C'\fR is a precomputed hash of the key
string, or zero if it has not been precomputed.  Returns a mortal scalar
representing the value associated with the key, or \f(CW&PL_sv_placeholder\fR
if there is no value associated with the key.
.RS 4
.Sp
.Vb 3
\& SV *  refcounted_he_fetch_pvn(const struct refcounted_he *chain,
\&                               const char *keypv, STRLEN keylen,
\&                               U32 hash, U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """refcounted_he_fetch_pvs""" 4
.el .IP \f(CWrefcounted_he_fetch_pvs\fR 4
.IX Xref "refcounted_he_fetch_pvs"
.IX Item "refcounted_he_fetch_pvs"
Like "refcounted_he_fetch_pvn", but takes a literal string
instead of a string/length pair, and no precomputed hash.
.RS 4
.Sp
.Vb 2
\& SV *  refcounted_he_fetch_pvs(const struct refcounted_he *chain,
\&                               "key", U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """refcounted_he_fetch_sv""" 4
.el .IP \f(CWrefcounted_he_fetch_sv\fR 4
.IX Xref "refcounted_he_fetch_sv"
.IX Item "refcounted_he_fetch_sv"
Like "refcounted_he_fetch_pvn", but takes a Perl scalar instead of a
string/length pair.
.RS 4
.Sp
.Vb 2
\& SV *  refcounted_he_fetch_sv(const struct refcounted_he *chain,
\&                              SV *key, U32 hash, U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """refcounted_he_free""" 4
.el .IP \f(CWrefcounted_he_free\fR 4
.IX Xref "refcounted_he_free"
.IX Item "refcounted_he_free"
Decrements the reference count of a \f(CW\*(C`refcounted_he\*(C'\fR by one.  If the
reference count reaches zero the structure's memory is freed, which
(recursively) causes a reduction of its parent \f(CW\*(C`refcounted_he\*(C'\fR's
reference count.  It is safe to pass a null pointer to this function:
no action occurs in this case.
.RS 4
.Sp
.Vb 1
\& void  refcounted_he_free(struct refcounted_he *he)
.Ve
.RE
.RS 4
.RE
.ie n .IP """refcounted_he_inc""" 4
.el .IP \f(CWrefcounted_he_inc\fR 4
.IX Xref "refcounted_he_inc"
.IX Item "refcounted_he_inc"
Increment the reference count of a \f(CW\*(C`refcounted_he\*(C'\fR.  The pointer to the
\&\f(CW\*(C`refcounted_he\*(C'\fR is also returned.  It is safe to pass a null pointer
to this function: no action occurs and a null pointer is returned.
.RS 4
.Sp
.Vb 2
\& struct refcounted_he *  refcounted_he_inc(
\&                                          struct refcounted_he *he)
.Ve
.RE
.RS 4
.RE
.ie n .IP """refcounted_he_new_pv""" 4
.el .IP \f(CWrefcounted_he_new_pv\fR 4
.IX Xref "refcounted_he_new_pv"
.IX Item "refcounted_he_new_pv"
Like "refcounted_he_new_pvn", but takes a nul-terminated string instead
of a string/length pair.
.RS 4
.Sp
.Vb 4
\& struct refcounted_he *  refcounted_he_new_pv(
\&                                      struct refcounted_he *parent,
\&                                      const char *key, U32 hash,
\&                                      SV *value, U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """refcounted_he_new_pvn""" 4
.el .IP \f(CWrefcounted_he_new_pvn\fR 4
.IX Xref "refcounted_he_new_pvn"
.IX Item "refcounted_he_new_pvn"
Creates a new \f(CW\*(C`refcounted_he\*(C'\fR.  This consists of a single key/value
pair and a reference to an existing \f(CW\*(C`refcounted_he\*(C'\fR chain (which may
be empty), and thus forms a longer chain.  When using the longer chain,
the new key/value pair takes precedence over any entry for the same key
further along the chain.
.Sp
The new key is specified by \f(CW\*(C`keypv\*(C'\fR and \f(CW\*(C`keylen\*(C'\fR.  If \f(CW\*(C`flags\*(C'\fR has
the \f(CW\*(C`REFCOUNTED_HE_KEY_UTF8\*(C'\fR bit set, the key octets are interpreted
as UTF\-8, otherwise they are interpreted as Latin\-1.  \f(CW\*(C`hash\*(C'\fR is
a precomputed hash of the key string, or zero if it has not been
precomputed.
.Sp
\&\f(CW\*(C`value\*(C'\fR is the scalar value to store for this key.  \f(CW\*(C`value\*(C'\fR is copied
by this function, which thus does not take ownership of any reference
to it, and later changes to the scalar will not be reflected in the
value visible in the \f(CW\*(C`refcounted_he\*(C'\fR.  Complex types of scalar will not
be stored with referential integrity, but will be coerced to strings.
\&\f(CW\*(C`value\*(C'\fR may be either null or \f(CW&PL_sv_placeholder\fR to indicate that no
value is to be associated with the key; this, as with any non-null value,
takes precedence over the existence of a value for the key further along
the chain.
.Sp
\&\f(CW\*(C`parent\*(C'\fR points to the rest of the \f(CW\*(C`refcounted_he\*(C'\fR chain to be
attached to the new \f(CW\*(C`refcounted_he\*(C'\fR.  This function takes ownership
of one reference to \f(CW\*(C`parent\*(C'\fR, and returns one reference to the new
\&\f(CW\*(C`refcounted_he\*(C'\fR.
.RS 4
.Sp
.Vb 5
\& struct refcounted_he *  refcounted_he_new_pvn(
\&                                      struct refcounted_he *parent,
\&                                      const char *keypv,
\&                                      STRLEN keylen, U32 hash,
\&                                      SV *value, U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """refcounted_he_new_pvs""" 4
.el .IP \f(CWrefcounted_he_new_pvs\fR 4
.IX Xref "refcounted_he_new_pvs"
.IX Item "refcounted_he_new_pvs"
Like "refcounted_he_new_pvn", but takes a literal string
instead of a string/length pair, and no precomputed hash.
.RS 4
.Sp
.Vb 3
\& struct refcounted_he *  refcounted_he_new_pvs(
\&                                      struct refcounted_he *parent,
\&                                      "key", SV *value, U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """refcounted_he_new_sv""" 4
.el .IP \f(CWrefcounted_he_new_sv\fR 4
.IX Xref "refcounted_he_new_sv"
.IX Item "refcounted_he_new_sv"
Like "refcounted_he_new_pvn", but takes a Perl scalar instead of a
string/length pair.
.RS 4
.Sp
.Vb 4
\& struct refcounted_he *  refcounted_he_new_sv(
\&                                      struct refcounted_he *parent,
\&                                      SV *key, U32 hash, SV *value,
\&                                      U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """unsharepvn""" 4
.el .IP \f(CWunsharepvn\fR 4
.IX Xref "unsharepvn"
.IX Item "unsharepvn"
If no one has access to shared string \f(CW\*(C`str\*(C'\fR with length \f(CW\*(C`len\*(C'\fR, free it.
.Sp
\&\f(CW\*(C`len\*(C'\fR and \f(CW\*(C`hash\*(C'\fR must both be valid for \f(CW\*(C`str\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& void  unsharepvn(const char *sv, I32 len, U32 hash)
.Ve
.RE
.RS 4
.RE
.SH Input/Output
.IX Header "Input/Output"
.ie n .IP """dirp_dup""" 4
.el .IP \f(CWdirp_dup\fR 4
.IX Xref "dirp_dup"
.IX Item "dirp_dup"
Duplicate a directory handle, returning a pointer to the cloned object.
.RS 4
.Sp
.Vb 1
\& DIR *  dirp_dup(DIR * const dp, CLONE_PARAMS * const param)
.Ve
.RE
.RS 4
.RE
.ie n .IP """fp_dup""" 4
.el .IP \f(CWfp_dup\fR 4
.IX Xref "fp_dup"
.IX Item "fp_dup"
Duplicate a file handle, returning a pointer to the cloned object.
.RS 4
.Sp
.Vb 2
\& PerlIO *  fp_dup(PerlIO * const fp, const char type,
\&                  CLONE_PARAMS * const param)
.Ve
.RE
.RS 4
.RE
.ie n .IP """my_fflush_all""" 4
.el .IP \f(CWmy_fflush_all\fR 4
.IX Xref "my_fflush_all"
.IX Item "my_fflush_all"
Implements \f(CW\*(C`PERL_FLUSHALL_FOR_CHILD\*(C'\fR on some platforms.
.RS 4
.Sp
.Vb 1
\& I32  my_fflush_all()
.Ve
.RE
.RS 4
.RE
.ie n .IP """my_mkostemp""" 4
.el .IP \f(CWmy_mkostemp\fR 4
.IX Xref "my_mkostemp"
.IX Item "my_mkostemp"
The C library \f(CWmkostemp(3)\fR if available, or a Perl implementation of it.
.Sp
NOTE: \f(CW\*(C`my_mkostemp\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_my_mkostemp\*(C'\fR
\&.
.RS 4
.Sp
.Vb 1
\& int  Perl_my_mkostemp(char *templte, int flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """my_mkstemp""" 4
.el .IP \f(CWmy_mkstemp\fR 4
.IX Xref "my_mkstemp"
.IX Item "my_mkstemp"
The C library \f(CWmkstemp(3)\fR if available, or a Perl implementation of it.
.Sp
NOTE: \f(CW\*(C`my_mkstemp\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_my_mkstemp\*(C'\fR
\&.
.RS 4
.Sp
.Vb 1
\& int  Perl_my_mkstemp(char *templte)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PL_last_in_gv""" 4
.el .IP \f(CWPL_last_in_gv\fR 4
.IX Xref "PL_last_in_gv"
.IX Item "PL_last_in_gv"
The GV which was last used for a filehandle input operation.  (\f(CW\*(C`<FH>\*(C'\fR)
.Sp
On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.
.RS 4
.Sp
.Vb 1
\& GV*  PL_last_in_gv
.Ve
.RE
.RS 4
.RE
.ie n .IP """PL_ofsgv""" 4
.el .IP \f(CWPL_ofsgv\fR 4
.IX Xref "PL_ofsgv"
.IX Item "PL_ofsgv"
The glob containing the output field separator \- \f(CW\*(C`*,\*(C'\fR in Perl space.
.Sp
On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.
.RS 4
.Sp
.Vb 1
\& GV*  PL_ofsgv
.Ve
.RE
.RS 4
.RE
.ie n .IP """PL_rs""" 4
.el .IP \f(CWPL_rs\fR 4
.IX Xref "PL_rs"
.IX Item "PL_rs"
The input record separator \- \f(CW$/\fR in Perl space.
.Sp
On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.
.RS 4
.Sp
.Vb 1
\& SV*  PL_rs
.Ve
.RE
.RS 4
.RE
.ie n .IP """start_glob""" 4
.el .IP \f(CWstart_glob\fR 4
.IX Xref "start_glob"
.IX Item "start_glob"
NOTE: \f(CW\*(C`start_glob\*(C'\fR is \fBexperimental\fR and may change or be
removed without notice.
.Sp
Function called by \f(CW\*(C`do_readline\*(C'\fR to spawn a glob (or do the glob inside
perl on VMS).  This code used to be inline, but now perl uses \f(CW\*(C`File::Glob\*(C'\fR
this glob starter is only used by miniperl during the build process,
or when PERL_EXTERNAL_GLOB is defined.
Moving it away shrinks \fIpp_hot.c\fR; shrinking \fIpp_hot.c\fR helps speed perl up.
.Sp
NOTE: \f(CW\*(C`start_glob\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_start_glob\*(C'\fR
with an \f(CW\*(C`aTHX_\*(C'\fR parameter.
.RS 4
.Sp
.Vb 1
\& PerlIO *  Perl_start_glob(pTHX_ SV *tmpglob, IO *io)
.Ve
.RE
.RS 4
.RE
.SH Integer
.IX Header "Integer"
There are currently no internal API items in Integer
.SH "I/O Formats"
.IX Header "I/O Formats"
There are currently no internal API items in I/O Formats
.SH "Lexer interface"
.IX Header "Lexer interface"
.ie n .IP """resume_compcv_and_save""" 4
.el .IP \f(CWresume_compcv_and_save\fR 4
.IX Xref "resume_compcv_and_save"
.IX Item "resume_compcv_and_save"
Resumes a buffer previously suspended by the \f(CW\*(C`suspend_compcv\*(C'\fR function, in a
way that will be re-suspended at the end of the scope so it can be used again
later.  This should be used within an \f(CW\*(C`ENTER\*(C'\fR/\f(CW\*(C`LEAVE\*(C'\fR scoped pair.
.RS 4
.Sp
.Vb 1
\& void  resume_compcv_and_save(struct suspended_compcv *buffer)
.Ve
.RE
.RS 4
.RE
.ie n .IP """resume_compcv_final""" 4
.el .IP \f(CWresume_compcv_final\fR 4
.IX Xref "resume_compcv_final"
.IX Item "resume_compcv_final"
Resumes the parser state previously saved using the \f(CW\*(C`suspend_compcv\*(C'\fR function
for a final time before being compiled into a full CV.  This should be used
within an \f(CW\*(C`ENTER\*(C'\fR/\f(CW\*(C`LEAVE\*(C'\fR scoped pair.
.RS 4
.Sp
.Vb 1
\& void  resume_compcv_final(struct suspended_compcv *buffer)
.Ve
.RE
.RS 4
.RE
.ie n .IP """validate_proto""" 4
.el .IP \f(CWvalidate_proto\fR 4
.IX Xref "validate_proto"
.IX Item "validate_proto"
NOTE: \f(CW\*(C`validate_proto\*(C'\fR is \fBexperimental\fR and may change or be
removed without notice.
.Sp
This function performs syntax checking on a prototype, \f(CW\*(C`proto\*(C'\fR.
If \f(CW\*(C`warn\*(C'\fR is true, any illegal characters or mismatched brackets
will trigger illegalproto warnings, declaring that they were
detected in the prototype for \f(CW\*(C`name\*(C'\fR.
.Sp
The return value is \f(CW\*(C`true\*(C'\fR if this is a valid prototype, and
\&\f(CW\*(C`false\*(C'\fR if it is not, regardless of whether \f(CW\*(C`warn\*(C'\fR was \f(CW\*(C`true\*(C'\fR or
\&\f(CW\*(C`false\*(C'\fR.
.Sp
Note that \f(CW\*(C`NULL\*(C'\fR is a valid \f(CW\*(C`proto\*(C'\fR and will always return \f(CW\*(C`true\*(C'\fR.
.RS 4
.Sp
.Vb 2
\& bool  validate_proto(SV *name, SV *proto, bool warn,
\&                      bool curstash)
.Ve
.RE
.RS 4
.RE
.SH Locales
.IX Header "Locales"
There are currently no internal API items in Locales
.SH Magic
.IX Header "Magic"
.ie n .IP """magic_clearhint""" 4
.el .IP \f(CWmagic_clearhint\fR 4
.IX Xref "magic_clearhint"
.IX Item "magic_clearhint"
Triggered by a delete from \f(CW\*(C`%^H\*(C'\fR, records the key to
\&\f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& int  magic_clearhint(SV *sv, MAGIC *mg)
.Ve
.RE
.RS 4
.RE
.ie n .IP """magic_clearhints""" 4
.el .IP \f(CWmagic_clearhints\fR 4
.IX Xref "magic_clearhints"
.IX Item "magic_clearhints"
Triggered by clearing \f(CW\*(C`%^H\*(C'\fR, resets \f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& int  magic_clearhints(SV *sv, MAGIC *mg)
.Ve
.RE
.RS 4
.RE
.ie n .IP """magic_methcall""" 4
.el .IP \f(CWmagic_methcall\fR 4
.IX Xref "magic_methcall"
.IX Item "magic_methcall"
Invoke a magic method (like FETCH).
.Sp
\&\f(CW\*(C`sv\*(C'\fR and \f(CW\*(C`mg\*(C'\fR are the tied thingy and the tie magic.
.Sp
\&\f(CW\*(C`meth\*(C'\fR is the name of the method to call.
.Sp
\&\f(CW\*(C`argc\*(C'\fR is the number of args (in addition to \f(CW$self\fR) to pass to the method.
.Sp
The \f(CW\*(C`flags\*(C'\fR can be:
.Sp
.Vb 4
\&    G_DISCARD     invoke method with G_DISCARD flag and don\*(Aqt
\&                  return a value
\&    G_UNDEF_FILL  fill the stack with argc pointers to
\&                  PL_sv_undef
.Ve
.Sp
The arguments themselves are any values following the \f(CW\*(C`flags\*(C'\fR argument.
.Sp
Returns the SV (if any) returned by the method, or \f(CW\*(C`NULL\*(C'\fR on failure.
.Sp
NOTE: \f(CW\*(C`magic_methcall\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_magic_methcall\*(C'\fR
with an \f(CW\*(C`aTHX_\*(C'\fR parameter.
.RS 4
.Sp
.Vb 2
\& SV *  Perl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg,
\&                           SV *meth, U32 flags, U32 argc, ...)
.Ve
.RE
.RS 4
.RE
.ie n .IP """magic_sethint""" 4
.el .IP \f(CWmagic_sethint\fR 4
.IX Xref "magic_sethint"
.IX Item "magic_sethint"
Triggered by a store to \f(CW\*(C`%^H\*(C'\fR, records the key/value pair to
\&\f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.  It is assumed that hints aren't storing
anything that would need a deep copy.  Maybe we should warn if we find a
reference.
.RS 4
.Sp
.Vb 1
\& int  magic_sethint(SV *sv, MAGIC *mg)
.Ve
.RE
.RS 4
.RE
.ie n .IP """mg_dup""" 4
.el .IP \f(CWmg_dup\fR 4
.IX Xref "mg_dup"
.IX Item "mg_dup"
Duplicate a chain of magic, returning a pointer to the cloned object.
.RS 4
.Sp
.Vb 1
\& MAGIC *  mg_dup(MAGIC *mg, CLONE_PARAMS * const param)
.Ve
.RE
.RS 4
.RE
.ie n .IP """mg_localize""" 4
.el .IP \f(CWmg_localize\fR 4
.IX Xref "mg_localize"
.IX Item "mg_localize"
Copy some of the magic from an existing SV to new localized version of that
SV.  Container magic (\fIe.g.\fR, \f(CW%ENV\fR, \f(CW$1\fR, \f(CW\*(C`tie\*(C'\fR)
gets copied, value magic doesn't (\fIe.g.\fR,
\&\f(CW\*(C`taint\*(C'\fR, \f(CW\*(C`pos\*(C'\fR).
.Sp
If \f(CW\*(C`setmagic\*(C'\fR is false then no set magic will be called on the new (empty) SV.
This typically means that assignment will soon follow (e.g. \f(CW\*(Aqlocal\ $x\ =\ $y\*(Aq\fR),
and that will handle the magic.
.RS 4
.Sp
.Vb 1
\& void  mg_localize(SV *sv, SV *nsv, bool setmagic)
.Ve
.RE
.RS 4
.RE
.SH "Memory Management"
.IX Header "Memory Management"
.ie n .IP """calloc""" 4
.el .IP \f(CWcalloc\fR 4
.IX Xref "calloc"
.IX Item "calloc"
Implements "\f(CW\*(C`Newxz\*(C'\fR" in perlapi which you should use instead.
.Sp
NOTE: \f(CW\*(C`calloc\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_calloc\*(C'\fR
\&.
.RS 4
.Sp
.Vb 1
\& Malloc_t  Perl_calloc(MEM_SIZE elements, MEM_SIZE size)
.Ve
.RE
.RS 4
.RE
.ie n .IP """malloc""" 4
.el .IP \f(CWmalloc\fR 4
.IX Xref "malloc"
.IX Item "malloc"
Implements "\f(CW\*(C`Newx\*(C'\fR" in perlapi which you should use instead.
.Sp
NOTE: \f(CW\*(C`malloc\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_malloc\*(C'\fR
\&.
.RS 4
.Sp
.Vb 1
\& Malloc_t  Perl_malloc(MEM_SIZE nbytes)
.Ve
.RE
.RS 4
.RE
.ie n .IP """mfree""" 4
.el .IP \f(CWmfree\fR 4
.IX Xref "mfree"
.IX Item "mfree"
Implements "\f(CW\*(C`Safefree\*(C'\fR" in perlapi which you should use instead.
.Sp
NOTE: \f(CW\*(C`mfree\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_mfree\*(C'\fR
\&.
.RS 4
.Sp
.Vb 1
\& Free_t  Perl_mfree(Malloc_t where)
.Ve
.RE
.RS 4
.RE
.ie n .IP """realloc""" 4
.el .IP \f(CWrealloc\fR 4
.IX Xref "realloc"
.IX Item "realloc"
Implements "\f(CW\*(C`Renew\*(C'\fR" in perlapi which you should use instead.
.Sp
NOTE: \f(CW\*(C`realloc\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_realloc\*(C'\fR
\&.
.RS 4
.Sp
.Vb 1
\& Malloc_t  Perl_realloc(Malloc_t where, MEM_SIZE nbytes)
.Ve
.RE
.RS 4
.RE
.SH MRO
.IX Header "MRO"
.ie n .IP """mro_get_linear_isa_dfs""" 4
.el .IP \f(CWmro_get_linear_isa_dfs\fR 4
.IX Xref "mro_get_linear_isa_dfs"
.IX Item "mro_get_linear_isa_dfs"
Returns the Depth-First Search linearization of \f(CW@ISA\fR
the given stash.  The return value is a read-only AV*
whose elements are string SVs giving class names.
\&\f(CW\*(C`level\*(C'\fR should be 0 (it is used internally in this
function's recursion).
.Sp
You are responsible for \f(CWSvREFCNT_inc()\fR on the
return value if you plan to store it anywhere
semi-permanently (otherwise it might be deleted
out from under you the next time the cache is
invalidated).
.RS 4
.Sp
.Vb 1
\& AV *  mro_get_linear_isa_dfs(HV *stash, U32 level)
.Ve
.RE
.RS 4
.RE
.ie n .IP """mro_isa_changed_in""" 4
.el .IP \f(CWmro_isa_changed_in\fR 4
.IX Xref "mro_isa_changed_in"
.IX Item "mro_isa_changed_in"
Takes the necessary steps (cache invalidations, mostly)
when the \f(CW@ISA\fR of the given package has changed.  Invoked
by the \f(CW\*(C`setisa\*(C'\fR magic, should not need to invoke directly.
.RS 4
.Sp
.Vb 1
\& void  mro_isa_changed_in(HV *stash)
.Ve
.RE
.RS 4
.RE
.ie n .IP """mro_package_moved""" 4
.el .IP \f(CWmro_package_moved\fR 4
.IX Xref "mro_package_moved"
.IX Item "mro_package_moved"
Call this function to signal to a stash that it has been assigned to
another spot in the stash hierarchy.  \f(CW\*(C`stash\*(C'\fR is the stash that has been
assigned.  \f(CW\*(C`oldstash\*(C'\fR is the stash it replaces, if any.  \f(CW\*(C`gv\*(C'\fR is the glob
that is actually being assigned to.
.Sp
This can also be called with a null first argument to
indicate that \f(CW\*(C`oldstash\*(C'\fR has been deleted.
.Sp
This function invalidates isa caches on the old stash, on all subpackages
nested inside it, and on the subclasses of all those, including
non-existent packages that have corresponding entries in \f(CW\*(C`stash\*(C'\fR.
.Sp
It also sets the effective names (\f(CW\*(C`HvENAME\*(C'\fR) on all the stashes as
appropriate.
.Sp
If the \f(CW\*(C`gv\*(C'\fR is present and is not in the symbol table, then this function
simply returns.  This checked will be skipped if \f(CW\*(C`flags & 1\*(C'\fR.
.RS 4
.Sp
.Vb 2
\& void  mro_package_moved(HV * const stash, HV * const oldstash,
\&                         const GV * const gv, U32 flags)
.Ve
.RE
.RS 4
.RE
.SH "Multicall Functions"
.IX Header "Multicall Functions"
There are currently no internal API items in Multicall Functions
.SH "Numeric Functions"
.IX Header "Numeric Functions"
.ie n .IP """isinfnansv""" 4
.el .IP \f(CWisinfnansv\fR 4
.IX Xref "isinfnansv"
.IX Item "isinfnansv"
Checks whether the argument would be either an infinity or \f(CW\*(C`NaN\*(C'\fR when used
as a number, but is careful not to trigger non-numeric or uninitialized
warnings.  it assumes the caller has done \f(CWSvGETMAGIC(sv)\fR already.
.Sp
Note that this always accepts trailing garbage (similar to \f(CW\*(C`grok_number_flags\*(C'\fR
with \f(CW\*(C`PERL_SCAN_TRAILING\*(C'\fR), so \f(CW"inferior"\fR and \f(CW"NAND gates"\fR will
return true.
.RS 4
.Sp
.Vb 1
\& bool  isinfnansv(SV *sv)
.Ve
.RE
.RS 4
.RE
.SH Optrees
.IX Header "Optrees"
.ie n .IP """newATTRSUB_x""" 4
.el .IP \f(CWnewATTRSUB_x\fR 4
.IX Xref "newATTRSUB_x"
.IX Item "newATTRSUB_x"
Construct a Perl subroutine, also performing some surrounding jobs.
.Sp
This function is expected to be called in a Perl compilation context,
and some aspects of the subroutine are taken from global variables
associated with compilation.  In particular, \f(CW\*(C`PL_compcv\*(C'\fR represents
the subroutine that is currently being compiled.  It must be non-null
when this function is called, and some aspects of the subroutine being
constructed are taken from it.  The constructed subroutine may actually
be a reuse of the \f(CW\*(C`PL_compcv\*(C'\fR object, but will not necessarily be so.
.Sp
If \f(CW\*(C`block\*(C'\fR is null then the subroutine will have no body, and for the
time being it will be an error to call it.  This represents a forward
subroutine declaration such as \f(CW\*(C`sub\ foo\ ($$);\*(C'\fR.  If \f(CW\*(C`block\*(C'\fR is
non-null then it provides the Perl code of the subroutine body, which
will be executed when the subroutine is called.  This body includes
any argument unwrapping code resulting from a subroutine signature or
similar.  The pad use of the code must correspond to the pad attached
to \f(CW\*(C`PL_compcv\*(C'\fR.  The code is not expected to include a \f(CW\*(C`leavesub\*(C'\fR or
\&\f(CW\*(C`leavesublv\*(C'\fR op; this function will add such an op.  \f(CW\*(C`block\*(C'\fR is consumed
by this function and will become part of the constructed subroutine.
.Sp
\&\f(CW\*(C`proto\*(C'\fR specifies the subroutine's prototype, unless one is supplied
as an attribute (see below).  If \f(CW\*(C`proto\*(C'\fR is null, then the subroutine
will not have a prototype.  If \f(CW\*(C`proto\*(C'\fR is non-null, it must point to a
\&\f(CW\*(C`const\*(C'\fR op whose value is a string, and the subroutine will have that
string as its prototype.  If a prototype is supplied as an attribute, the
attribute takes precedence over \f(CW\*(C`proto\*(C'\fR, but in that case \f(CW\*(C`proto\*(C'\fR should
preferably be null.  In any case, \f(CW\*(C`proto\*(C'\fR is consumed by this function.
.Sp
\&\f(CW\*(C`attrs\*(C'\fR supplies attributes to be applied the subroutine.  A handful of
attributes take effect by built-in means, being applied to \f(CW\*(C`PL_compcv\*(C'\fR
immediately when seen.  Other attributes are collected up and attached
to the subroutine by this route.  \f(CW\*(C`attrs\*(C'\fR may be null to supply no
attributes, or point to a \f(CW\*(C`const\*(C'\fR op for a single attribute, or point
to a \f(CW\*(C`list\*(C'\fR op whose children apart from the \f(CW\*(C`pushmark\*(C'\fR are \f(CW\*(C`const\*(C'\fR
ops for one or more attributes.  Each \f(CW\*(C`const\*(C'\fR op must be a string,
giving the attribute name optionally followed by parenthesised arguments,
in the manner in which attributes appear in Perl source.  The attributes
will be applied to the sub by this function.  \f(CW\*(C`attrs\*(C'\fR is consumed by
this function.
.Sp
If \f(CW\*(C`o_is_gv\*(C'\fR is false and \f(CW\*(C`o\*(C'\fR is null, then the subroutine will
be anonymous.  If \f(CW\*(C`o_is_gv\*(C'\fR is false and \f(CW\*(C`o\*(C'\fR is non-null, then \f(CW\*(C`o\*(C'\fR
must point to a \f(CW\*(C`const\*(C'\fR OP, which will be consumed by this function,
and its string value supplies a name for the subroutine.  The name may
be qualified or unqualified, and if it is unqualified then a default
stash will be selected in some manner.  If \f(CW\*(C`o_is_gv\*(C'\fR is true, then \f(CW\*(C`o\*(C'\fR
doesn't point to an \f(CW\*(C`OP\*(C'\fR at all, but is instead a cast pointer to a \f(CW\*(C`GV\*(C'\fR
by which the subroutine will be named.
.Sp
If there is already a subroutine of the specified name, then the new
sub will either replace the existing one in the glob or be merged with
the existing one.  A warning may be generated about redefinition.
.Sp
If the subroutine has one of a few special names, such as \f(CW\*(C`BEGIN\*(C'\fR or
\&\f(CW\*(C`END\*(C'\fR, then it will be claimed by the appropriate queue for automatic
running of phase-related subroutines.  In this case the relevant glob will
be left not containing any subroutine, even if it did contain one before.
In the case of \f(CW\*(C`BEGIN\*(C'\fR, the subroutine will be executed and the reference
to it disposed of before this function returns.
.Sp
The function returns a pointer to the constructed subroutine.  If the sub
is anonymous then ownership of one counted reference to the subroutine
is transferred to the caller.  If the sub is named then the caller does
not get ownership of a reference.  In most such cases, where the sub
has a non-phase name, the sub will be alive at the point it is returned
by virtue of being contained in the glob that names it.  A phase-named
subroutine will usually be alive by virtue of the reference owned by the
phase's automatic run queue.  But a \f(CW\*(C`BEGIN\*(C'\fR subroutine, having already
been executed, will quite likely have been destroyed already by the
time this function returns, making it erroneous for the caller to make
any use of the returned pointer.  It is the caller's responsibility to
ensure that it knows which of these situations applies.
.RS 4
.Sp
.Vb 2
\& CV *  newATTRSUB_x(I32 floor, OP *o, OP *proto, OP *attrs,
\&                    OP *block, bool o_is_gv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """newMYSUB""" 4
.el .IP \f(CWnewMYSUB\fR 4
.IX Xref "newMYSUB"
.IX Item "newMYSUB"
Construct a Perl lexical subroutine, also performing some surrounding jobs, and
returning a pointer to the constructed subroutine.
.Sp
Similar in action to "\f(CW\*(C`newATTRSUB_x\*(C'\fR" in perlintern.
.RS 4
.Sp
.Vb 1
\& CV *  newMYSUB(I32 floor, OP *o, OP *proto, OP *attrs, OP *block)
.Ve
.RE
.RS 4
.RE
.ie n .IP """newXS_len_flags""" 4
.el .IP \f(CWnewXS_len_flags\fR 4
.IX Xref "newXS_len_flags"
.IX Item "newXS_len_flags"
Construct an XS subroutine, also performing some surrounding jobs.
.Sp
The subroutine will have the entry point \f(CW\*(C`subaddr\*(C'\fR.  It will have
the prototype specified by the nul-terminated string \f(CW\*(C`proto\*(C'\fR, or
no prototype if \f(CW\*(C`proto\*(C'\fR is null.  The prototype string is copied;
the caller can mutate the supplied string afterwards.  If \f(CW\*(C`filename\*(C'\fR
is non-null, it must be a nul-terminated filename, and the subroutine
will have its \f(CW\*(C`CvFILE\*(C'\fR set accordingly.  By default \f(CW\*(C`CvFILE\*(C'\fR is set to
point directly to the supplied string, which must be static.  If \f(CW\*(C`flags\*(C'\fR
has the \f(CW\*(C`XS_DYNAMIC_FILENAME\*(C'\fR bit set, then a copy of the string will
be taken instead.
.Sp
Other aspects of the subroutine will be left in their default state.
If anything else needs to be done to the subroutine for it to function
correctly, it is the caller's responsibility to do that after this
function has constructed it.  However, beware of the subroutine
potentially being destroyed before this function returns, as described
below.
.Sp
If \f(CW\*(C`name\*(C'\fR is null then the subroutine will be anonymous, with its
\&\f(CW\*(C`CvGV\*(C'\fR referring to an \f(CW\*(C`_\|_ANON_\|_\*(C'\fR glob.  If \f(CW\*(C`name\*(C'\fR is non-null then the
subroutine will be named accordingly, referenced by the appropriate glob.
\&\f(CW\*(C`name\*(C'\fR is a string of length \f(CW\*(C`len\*(C'\fR bytes giving a sigilless symbol name,
in UTF\-8 if \f(CW\*(C`flags\*(C'\fR has the \f(CW\*(C`SVf_UTF8\*(C'\fR bit set and in Latin\-1 otherwise.
The name may be either qualified or unqualified, with the stash defaulting
in the same manner as for \f(CW\*(C`gv_fetchpvn_flags\*(C'\fR.  \f(CW\*(C`flags\*(C'\fR may contain
flag bits understood by \f(CW\*(C`gv_fetchpvn_flags\*(C'\fR with the same meaning as
they have there, such as \f(CW\*(C`GV_ADDWARN\*(C'\fR.  The symbol is always added to
the stash if necessary, with \f(CW\*(C`GV_ADDMULTI\*(C'\fR semantics.
.Sp
If there is already a subroutine of the specified name, then the new sub
will replace the existing one in the glob.  A warning may be generated
about the redefinition.  If the old subroutine was \f(CW\*(C`CvCONST\*(C'\fR then the
decision about whether to warn is influenced by an expectation about
whether the new subroutine will become a constant of similar value.
That expectation is determined by \f(CW\*(C`const_svp\*(C'\fR.  (Note that the call to
this function doesn't make the new subroutine \f(CW\*(C`CvCONST\*(C'\fR in any case;
that is left to the caller.)  If \f(CW\*(C`const_svp\*(C'\fR is null then it indicates
that the new subroutine will not become a constant.  If \f(CW\*(C`const_svp\*(C'\fR
is non-null then it indicates that the new subroutine will become a
constant, and it points to an \f(CW\*(C`SV*\*(C'\fR that provides the constant value
that the subroutine will have.
.Sp
If the subroutine has one of a few special names, such as \f(CW\*(C`BEGIN\*(C'\fR or
\&\f(CW\*(C`END\*(C'\fR, then it will be claimed by the appropriate queue for automatic
running of phase-related subroutines.  In this case the relevant glob will
be left not containing any subroutine, even if it did contain one before.
In the case of \f(CW\*(C`BEGIN\*(C'\fR, the subroutine will be executed and the reference
to it disposed of before this function returns, and also before its
prototype is set.  If a \f(CW\*(C`BEGIN\*(C'\fR subroutine would not be sufficiently
constructed by this function to be ready for execution then the caller
must prevent this happening by giving the subroutine a different name.
.Sp
The function returns a pointer to the constructed subroutine.  If the sub
is anonymous then ownership of one counted reference to the subroutine
is transferred to the caller.  If the sub is named then the caller does
not get ownership of a reference.  In most such cases, where the sub
has a non-phase name, the sub will be alive at the point it is returned
by virtue of being contained in the glob that names it.  A phase-named
subroutine will usually be alive by virtue of the reference owned by the
phase's automatic run queue.  But a \f(CW\*(C`BEGIN\*(C'\fR subroutine, having already
been executed, will quite likely have been destroyed already by the
time this function returns, making it erroneous for the caller to make
any use of the returned pointer.  It is the caller's responsibility to
ensure that it knows which of these situations applies.
.RS 4
.Sp
.Vb 5
\& CV *  newXS_len_flags(const char *name, STRLEN len,
\&                       XSUBADDR_t subaddr,
\&                       const char * const filename,
\&                       const char * const proto, SV ** const_svp,
\&                       U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """op_refcnt_lock""" 4
.el .IP \f(CWop_refcnt_lock\fR 4
.IX Xref "op_refcnt_lock"
.IX Item "op_refcnt_lock"
Implements the \f(CW\*(C`OP_REFCNT_LOCK\*(C'\fR macro which you should use instead.
.RS 4
.Sp
.Vb 1
\& void  op_refcnt_lock()
.Ve
.RE
.RS 4
.RE
.ie n .IP """op_refcnt_unlock""" 4
.el .IP \f(CWop_refcnt_unlock\fR 4
.IX Xref "op_refcnt_unlock"
.IX Item "op_refcnt_unlock"
Implements the \f(CW\*(C`OP_REFCNT_UNLOCK\*(C'\fR macro which you should use instead.
.RS 4
.Sp
.Vb 1
\& void  op_refcnt_unlock()
.Ve
.RE
.RS 4
.RE
.ie n .IP """traverse_op_tree""" 4
.el .IP \f(CWtraverse_op_tree\fR 4
.IX Xref "traverse_op_tree"
.IX Item "traverse_op_tree"
Return the next op in a depth-first traversal of the op tree,
returning NULL when the traversal is complete.
.Sp
The initial call must supply the root of the tree as both top and o.
.Sp
For now it's static, but it may be exposed to the API in the future.
.RS 4
.Sp
.Vb 1
\& OP *  traverse_op_tree(OP *top, OP *o)
.Ve
.RE
.RS 4
.RE
.SH "Pack and Unpack"
.IX Header "Pack and Unpack"
There are currently no internal API items in Pack and Unpack
.SH "Pad Data Structures"
.IX Header "Pad Data Structures"
.ie n .IP """CX_CURPAD_SAVE""" 4
.el .IP \f(CWCX_CURPAD_SAVE\fR 4
.IX Xref "CX_CURPAD_SAVE"
.IX Item "CX_CURPAD_SAVE"
Save the current pad in the given context block structure.
.RS 4
.Sp
.Vb 1
\& void  CX_CURPAD_SAVE(struct context)
.Ve
.RE
.RS 4
.RE
.ie n .IP """CX_CURPAD_SV""" 4
.el .IP \f(CWCX_CURPAD_SV\fR 4
.IX Xref "CX_CURPAD_SV"
.IX Item "CX_CURPAD_SV"
Access the SV at offset \f(CW\*(C`po\*(C'\fR in the saved current pad in the given
context block structure (can be used as an lvalue).
.RS 4
.Sp
.Vb 1
\& SV *  CX_CURPAD_SV(struct context, PADOFFSET po)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_BASE_SV""" 4
.el .IP \f(CWPAD_BASE_SV\fR 4
.IX Xref "PAD_BASE_SV"
.IX Item "PAD_BASE_SV"
Get the value from slot \f(CW\*(C`po\*(C'\fR in the base (DEPTH=1) pad of a padlist
.RS 4
.Sp
.Vb 1
\& SV *  PAD_BASE_SV(PADLIST padlist, PADOFFSET po)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_CLONE_VARS""" 4
.el .IP \f(CWPAD_CLONE_VARS\fR 4
.IX Xref "PAD_CLONE_VARS"
.IX Item "PAD_CLONE_VARS"
Clone the state variables associated with running and compiling pads.
.RS 4
.Sp
.Vb 2
\& void  PAD_CLONE_VARS(PerlInterpreter *proto_perl,
\&                      CLONE_PARAMS* param)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_COMPNAME_FLAGS""" 4
.el .IP \f(CWPAD_COMPNAME_FLAGS\fR 4
.IX Xref "PAD_COMPNAME_FLAGS"
.IX Item "PAD_COMPNAME_FLAGS"
Return the flags for the current compiling pad name
at offset \f(CW\*(C`po\*(C'\fR.  Assumes a valid slot entry.
.RS 4
.Sp
.Vb 1
\& U32  PAD_COMPNAME_FLAGS(PADOFFSET po)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_COMPNAME_GEN""" 4
.el .IP \f(CWPAD_COMPNAME_GEN\fR 4
.IX Xref "PAD_COMPNAME_GEN"
.IX Item "PAD_COMPNAME_GEN"
The generation number of the name at offset \f(CW\*(C`po\*(C'\fR in the current
compiling pad (lvalue).
.RS 4
.Sp
.Vb 1
\& STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_COMPNAME_GEN_set""" 4
.el .IP \f(CWPAD_COMPNAME_GEN_set\fR 4
.IX Xref "PAD_COMPNAME_GEN_set"
.IX Item "PAD_COMPNAME_GEN_set"
Sets the generation number of the name at offset \f(CW\*(C`po\*(C'\fR in the current
ling pad (lvalue) to \f(CW\*(C`gen\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& STRLEN  PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_COMPNAME_OURSTASH""" 4
.el .IP \f(CWPAD_COMPNAME_OURSTASH\fR 4
.IX Xref "PAD_COMPNAME_OURSTASH"
.IX Item "PAD_COMPNAME_OURSTASH"
Return the stash associated with an \f(CW\*(C`our\*(C'\fR variable.
Assumes the slot entry is a valid \f(CW\*(C`our\*(C'\fR lexical.
.RS 4
.Sp
.Vb 1
\& HV *  PAD_COMPNAME_OURSTASH(PADOFFSET po)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_COMPNAME_PV""" 4
.el .IP \f(CWPAD_COMPNAME_PV\fR 4
.IX Xref "PAD_COMPNAME_PV"
.IX Item "PAD_COMPNAME_PV"
Return the name of the current compiling pad name
at offset \f(CW\*(C`po\*(C'\fR.  Assumes a valid slot entry.
.RS 4
.Sp
.Vb 1
\& char *  PAD_COMPNAME_PV(PADOFFSET po)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_COMPNAME_TYPE""" 4
.el .IP \f(CWPAD_COMPNAME_TYPE\fR 4
.IX Xref "PAD_COMPNAME_TYPE"
.IX Item "PAD_COMPNAME_TYPE"
Return the type (stash) of the current compiling pad name at offset
\&\f(CW\*(C`po\*(C'\fR.  Must be a valid name.  Returns null if not typed.
.RS 4
.Sp
.Vb 1
\& HV *  PAD_COMPNAME_TYPE(PADOFFSET po)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PadnameIsFIELD""" 4
.el .IP \f(CWPadnameIsFIELD\fR 4
.IX Xref "PadnameIsFIELD"
.IX Item "PadnameIsFIELD"
Whether this is a "field" variable.  PADNAMEs where this is true will
have additional information available via \f(CW\*(C`PadnameFIELDINFO\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& bool  PadnameIsFIELD(PADNAME * pn)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PadnameIsOUR""" 4
.el .IP \f(CWPadnameIsOUR\fR 4
.IX Xref "PadnameIsOUR"
.IX Item "PadnameIsOUR"
Whether this is an "our" variable.
.RS 4
.Sp
.Vb 1
\& bool  PadnameIsOUR(PADNAME * pn)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PadnameIsSTATE""" 4
.el .IP \f(CWPadnameIsSTATE\fR 4
.IX Xref "PadnameIsSTATE"
.IX Item "PadnameIsSTATE"
Whether this is a "state" variable.
.RS 4
.Sp
.Vb 1
\& bool  PadnameIsSTATE(PADNAME * pn)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PadnameOURSTASH""" 4
.el .IP \f(CWPadnameOURSTASH\fR 4
.IX Xref "PadnameOURSTASH"
.IX Item "PadnameOURSTASH"
The stash in which this "our" variable was declared.
.RS 4
.Sp
.Vb 1
\& HV *  PadnameOURSTASH(PADNAME * pn)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PadnameOUTER""" 4
.el .IP \f(CWPadnameOUTER\fR 4
.IX Xref "PadnameOUTER"
.IX Item "PadnameOUTER"
Whether this entry belongs to an outer pad.  Entries for which this is true
are often referred to as 'fake'.
.RS 4
.Sp
.Vb 1
\& bool  PadnameOUTER(PADNAME * pn)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PadnameTYPE""" 4
.el .IP \f(CWPadnameTYPE\fR 4
.IX Xref "PadnameTYPE"
.IX Item "PadnameTYPE"
The stash associated with a typed lexical.  This returns the \f(CW%Foo::\fR hash
for \f(CW\*(C`my Foo $bar\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& HV *  PadnameTYPE(PADNAME * pn)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_RESTORE_LOCAL""" 4
.el .IP \f(CWPAD_RESTORE_LOCAL\fR 4
.IX Xref "PAD_RESTORE_LOCAL"
.IX Item "PAD_RESTORE_LOCAL"
Restore the old pad saved into the local variable \f(CW\*(C`opad\*(C'\fR by \f(CWPAD_SAVE_LOCAL()\fR
.RS 4
.Sp
.Vb 1
\& void  PAD_RESTORE_LOCAL(PAD *opad)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_SAVE_LOCAL""" 4
.el .IP \f(CWPAD_SAVE_LOCAL\fR 4
.IX Xref "PAD_SAVE_LOCAL"
.IX Item "PAD_SAVE_LOCAL"
Save the current pad to the local variable \f(CW\*(C`opad\*(C'\fR, then make the
current pad equal to \f(CW\*(C`npad\*(C'\fR
.RS 4
.Sp
.Vb 1
\& void  PAD_SAVE_LOCAL(PAD *opad, PAD *npad)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_SAVE_SETNULLPAD""" 4
.el .IP \f(CWPAD_SAVE_SETNULLPAD\fR 4
.IX Xref "PAD_SAVE_SETNULLPAD"
.IX Item "PAD_SAVE_SETNULLPAD"
Save the current pad then set it to null.
.RS 4
.Sp
.Vb 1
\& void  PAD_SAVE_SETNULLPAD()
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_SET_CUR""" 4
.el .IP \f(CWPAD_SET_CUR\fR 4
.IX Xref "PAD_SET_CUR"
.IX Item "PAD_SET_CUR"
Set the current pad to be pad \f(CW\*(C`n\*(C'\fR in the padlist, saving
the previous current pad.  NB currently this macro expands to a string too
long for some compilers, so it's best to replace it with
.Sp
.Vb 2
\&    SAVECOMPPAD();
\&    PAD_SET_CUR_NOSAVE(padlist,n);
.Ve
.RS 4
.Sp
.Vb 1
\& void  PAD_SET_CUR(PADLIST padlist, I32 n)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_SET_CUR_NOSAVE""" 4
.el .IP \f(CWPAD_SET_CUR_NOSAVE\fR 4
.IX Xref "PAD_SET_CUR_NOSAVE"
.IX Item "PAD_SET_CUR_NOSAVE"
like PAD_SET_CUR, but without the save
.RS 4
.Sp
.Vb 1
\& void  PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_SETSV""" 4
.el .IP \f(CWPAD_SETSV\fR 4
.IX Xref "PAD_SETSV"
.IX Item "PAD_SETSV"
Set the slot at offset \f(CW\*(C`po\*(C'\fR in the current pad to \f(CW\*(C`sv\*(C'\fR
.RS 4
.Sp
.Vb 1
\& SV *  PAD_SETSV(PADOFFSET po, SV* sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_SV""" 4
.el .IP \f(CWPAD_SV\fR 4
.IX Xref "PAD_SV"
.IX Item "PAD_SV"
Get the value at offset \f(CW\*(C`po\*(C'\fR in the current pad
.RS 4
.Sp
.Vb 1
\& SV *  PAD_SV(PADOFFSET po)
.Ve
.RE
.RS 4
.RE
.ie n .IP """PAD_SVl""" 4
.el .IP \f(CWPAD_SVl\fR 4
.IX Xref "PAD_SVl"
.IX Item "PAD_SVl"
Lightweight and lvalue version of \f(CW\*(C`PAD_SV\*(C'\fR.
Get or set the value at offset \f(CW\*(C`po\*(C'\fR in the current pad.
Unlike \f(CW\*(C`PAD_SV\*(C'\fR, does not print diagnostics with \-DX.
For internal use only.
.RS 4
.Sp
.Vb 1
\& SV *  PAD_SVl(PADOFFSET po)
.Ve
.RE
.RS 4
.RE
.ie n .IP """SAVECLEARSV""" 4
.el .IP \f(CWSAVECLEARSV\fR 4
.IX Xref "SAVECLEARSV"
.IX Item "SAVECLEARSV"
Clear the pointed to pad value on scope exit.  (i.e. the runtime action of
\&\f(CW\*(C`my\*(C'\fR)
.RS 4
.Sp
.Vb 1
\& void  SAVECLEARSV(SV **svp)
.Ve
.RE
.RS 4
.RE
.ie n .IP """SAVECOMPPAD""" 4
.el .IP \f(CWSAVECOMPPAD\fR 4
.IX Xref "SAVECOMPPAD"
.IX Item "SAVECOMPPAD"
save \f(CW\*(C`PL_comppad\*(C'\fR and \f(CW\*(C`PL_curpad\*(C'\fR
.RS 4
.Sp
.Vb 1
\& void  SAVECOMPPAD()
.Ve
.RE
.RS 4
.RE
.ie n .IP """SAVEPADSV""" 4
.el .IP \f(CWSAVEPADSV\fR 4
.IX Xref "SAVEPADSV"
.IX Item "SAVEPADSV"
Save a pad slot (used to restore after an iteration)
.RS 4
.Sp
.Vb 1
\& void  SAVEPADSV(PADOFFSET po)
.Ve
.RE
.RS 4
.RE
.SH "Password and Group access"
.IX Header "Password and Group access"
There are currently no internal API items in Password and Group access
.SH "Paths to system commands"
.IX Header "Paths to system commands"
There are currently no internal API items in Paths to system commands
.SH "Prototype information"
.IX Header "Prototype information"
There are currently no internal API items in Prototype information
.SH "Reference-counted stack manipulation"
.IX Header "Reference-counted stack manipulation"
There are currently no internal API items in Reference-counted stack manipulation
.SH "REGEXP Functions"
.IX Xref "RX_OFFSp"
.IX Header "REGEXP Functions"
.ie n .IP """regnode""" 4
.el .IP \f(CWregnode\fR 4
.IX Item "regnode"
Described in perlreguts.
.SH "Reports and Formats"
.IX Header "Reports and Formats"
There are currently no internal API items in Reports and Formats
.SH Signals
.IX Header "Signals"
There are currently no internal API items in Signals
.SH "Site configuration"
.IX Header "Site configuration"
There are currently no internal API items in Site configuration
.SH "Sockets configuration values"
.IX Header "Sockets configuration values"
There are currently no internal API items in Sockets configuration values
.SH "Source Filters"
.IX Header "Source Filters"
There are currently no internal API items in Source Filters
.SH "Stack Manipulation Macros"
.IX Header "Stack Manipulation Macros"
.ie n .IP """djSP""" 4
.el .IP \f(CWdjSP\fR 4
.IX Xref "djSP"
.IX Item "djSP"
Declare Just \f(CW\*(C`SP\*(C'\fR.  This is actually identical to \f(CW\*(C`dSP\*(C'\fR, and declares
a local copy of perl's stack pointer, available via the \f(CW\*(C`SP\*(C'\fR macro.
See \f(CW\*(C`"SP" in perlapi\*(C'\fR.  (Available for backward source code compatibility with
the old (Perl 5.005) thread model.)
.RS 4
.Sp
.Vb 1
\&   djSP();
.Ve
.RE
.RS 4
.RE
.ie n .IP """LVRET""" 4
.el .IP \f(CWLVRET\fR 4
.IX Xref "LVRET"
.IX Item "LVRET"
True if this op will be the return value of an lvalue subroutine
.ie n .IP """save_alloc""" 4
.el .IP \f(CWsave_alloc\fR 4
.IX Xref "save_alloc"
.IX Item "save_alloc"
Implements "\f(CW\*(C`SSNEW\*(C'\fR" in perlapi and kin, which should be used instead of this
function.
.RS 4
.Sp
.Vb 1
\& SSize_t  save_alloc(SSize_t size, I32 pad)
.Ve
.RE
.RS 4
.RE
.SH "String Handling"
.IX Header "String Handling"
.ie n .IP """delimcpy_no_escape""" 4
.el .IP \f(CWdelimcpy_no_escape\fR 4
.IX Xref "delimcpy_no_escape"
.IX Item "delimcpy_no_escape"
Copy a source buffer to a destination buffer, stopping at (but not including)
the first occurrence in the source of the delimiter byte, \f(CW\*(C`delim\*(C'\fR.  The source
is the bytes between \f(CW\*(C`from\*(C'\fR\ and\ \f(CW\*(C`from_end\*(C'\fR\ \-\ 1.  Similarly, the dest is
\&\f(CW\*(C`to\*(C'\fR up to \f(CW\*(C`to_end\*(C'\fR.
.Sp
The number of bytes copied is written to \f(CW*retlen\fR.
.Sp
Returns the position of \f(CW\*(C`delim\*(C'\fR in the \f(CW\*(C`from\*(C'\fR buffer, but if there is no
such occurrence before \f(CW\*(C`from_end\*(C'\fR, then \f(CW\*(C`from_end\*(C'\fR is returned, and the entire
buffer \f(CW\*(C`from\*(C'\fR\ ..\ \f(CW\*(C`from_end\*(C'\fR\ \-\ 1 is copied.
.Sp
If there is room in the destination available after the copy, an extra
terminating safety \f(CW\*(C`NUL\*(C'\fR byte is appended (not included in the returned
length).
.Sp
The error case is if the destination buffer is not large enough to accommodate
everything that should be copied.  In this situation, a value larger than
\&\f(CW\*(C`to_end\*(C'\fR\ \-\ \f(CW\*(C`to\*(C'\fR is written to \f(CW*retlen\fR, and as much of the source as
fits will be written to the destination.  Not having room for the safety \f(CW\*(C`NUL\*(C'\fR
is not considered an error.
.RS 4
.Sp
.Vb 3
\& char *  delimcpy_no_escape(char *to, const char *to_end,
\&                            const char *from, const char *from_end,
\&                            const int delim, I32 *retlen)
.Ve
.RE
.RS 4
.RE
.ie n .IP """my_cxt_init""" 4
.el .IP \f(CWmy_cxt_init\fR 4
.IX Xref "my_cxt_init"
.IX Item "my_cxt_init"
Implements the "\f(CW\*(C`MY_CXT_INIT\*(C'\fR" in perlxs macro, which you should use instead.
.Sp
The first time a module is loaded, the global \f(CW\*(C`PL_my_cxt_index\*(C'\fR is incremented,
and that value is assigned to that module's static \f(CW\*(C`my_cxt_index\*(C'\fR (whose
address is passed as an arg).  Then, for each interpreter this function is
called for, it makes sure a \f(CW\*(C`void*\*(C'\fR slot is available to hang the static data
off, by allocating or extending the interpreter's \f(CW\*(C`PL_my_cxt_list\*(C'\fR array
.Sp
NOTE: \f(CW\*(C`my_cxt_init\*(C'\fR must be explicitly called as
\&\f(CW\*(C`Perl_my_cxt_init\*(C'\fR
with an \f(CW\*(C`aTHX_\*(C'\fR parameter.
.RS 4
.Sp
.Vb 1
\& void *  Perl_my_cxt_init(pTHX_ int *indexp, size_t size)
.Ve
.RE
.RS 4
.RE
.ie n .IP """quadmath_format_needed""" 4
.el .IP \f(CWquadmath_format_needed\fR 4
.IX Xref "quadmath_format_needed"
.IX Item "quadmath_format_needed"
\&\f(CWquadmath_format_needed()\fR returns true if the \f(CW\*(C`format\*(C'\fR string seems to
contain at least one non-Q-prefixed \f(CW\*(C`%[efgaEFGA]\*(C'\fR format specifier,
or returns false otherwise.
.Sp
The format specifier detection is not complete printf-syntax detection,
but it should catch most common cases.
.Sp
If true is returned, those arguments \fBshould\fR in theory be processed
with \f(CWquadmath_snprintf()\fR, but in case there is more than one such
format specifier (see "quadmath_format_valid"), and if there is
anything else beyond that one (even just a single byte), they
\&\fBcannot\fR be processed because \f(CWquadmath_snprintf()\fR is very strict,
accepting only one format spec, and nothing else.
In this case, the code should probably fail.
.RS 4
.Sp
.Vb 1
\& bool  quadmath_format_needed(const char *format)
.Ve
.RE
.RS 4
.RE
.ie n .IP """quadmath_format_valid""" 4
.el .IP \f(CWquadmath_format_valid\fR 4
.IX Xref "quadmath_format_valid"
.IX Item "quadmath_format_valid"
\&\f(CWquadmath_snprintf()\fR is very strict about its \f(CW\*(C`format\*(C'\fR string and will
fail, returning \-1, if the format is invalid.  It accepts exactly
one format spec.
.Sp
\&\f(CWquadmath_format_valid()\fR checks that the intended single spec looks
sane: begins with \f(CW\*(C`%\*(C'\fR, has only one \f(CW\*(C`%\*(C'\fR, ends with \f(CW\*(C`[efgaEFGA]\*(C'\fR,
and has \f(CW\*(C`Q\*(C'\fR before it.  This is not a full "printf syntax check",
just the basics.
.Sp
Returns true if it is valid, false if not.
.Sp
See also "quadmath_format_needed".
.RS 4
.Sp
.Vb 1
\& bool  quadmath_format_valid(const char *format)
.Ve
.RE
.RS 4
.RE
.SH "SV Flags"
.IX Header "SV Flags"
.ie n .IP """SVt_INVLIST""" 4
.el .IP \f(CWSVt_INVLIST\fR 4
.IX Xref "SVt_INVLIST"
.IX Item "SVt_INVLIST"
Type flag for scalars.  See "svtype" in perlapi.
.SH "SV Handling"
.IX Header "SV Handling"
.ie n .IP """PL_Sv""" 4
.el .IP \f(CWPL_Sv\fR 4
.IX Xref "PL_Sv"
.IX Item "PL_Sv"
A scratch pad SV for whatever temporary use you need.  Chiefly used as a
fallback by macros on platforms where "PERL_USE_GCC_BRACE_GROUPS" in perlapi> is
unavailable, and which would otherwise evaluate their SV parameter more than
once.
.Sp
\&\fBBUT BEWARE\fR, if this is used in a situation where something that is using it
is in a call stack with something else that is using it, this variable would
get zapped, leading to hard-to-diagnose errors.
.RS 4
.Sp
.Vb 1
\&   PL_Sv
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_add_arena""" 4
.el .IP \f(CWsv_add_arena\fR 4
.IX Xref "sv_add_arena"
.IX Item "sv_add_arena"
Given a chunk of memory, link it to the head of the list of arenas,
and split it into a list of free SVs.
.RS 4
.Sp
.Vb 2
\& void  sv_add_arena(char * const ptr, const U32 size,
\&                    const U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_2bool""" 4
.el .IP \f(CWsv_2bool\fR 4
.IX Xref "sv_2bool"
.IX Item "sv_2bool"
This macro is only used by \f(CWsv_true()\fR or its macro equivalent, and only if
the latter's argument is neither \f(CW\*(C`SvPOK\*(C'\fR, \f(CW\*(C`SvIOK\*(C'\fR nor \f(CW\*(C`SvNOK\*(C'\fR.
It calls \f(CW\*(C`sv_2bool_flags\*(C'\fR with the \f(CW\*(C`SV_GMAGIC\*(C'\fR flag.
.RS 4
.Sp
.Vb 1
\& bool  sv_2bool(SV * const sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_2bool_flags""" 4
.el .IP \f(CWsv_2bool_flags\fR 4
.IX Xref "sv_2bool_flags"
.IX Item "sv_2bool_flags"
This function is only used by \f(CWsv_true()\fR and friends,  and only if
the latter's argument is neither \f(CW\*(C`SvPOK\*(C'\fR, \f(CW\*(C`SvIOK\*(C'\fR nor \f(CW\*(C`SvNOK\*(C'\fR.  If the flags
contain \f(CW\*(C`SV_GMAGIC\*(C'\fR, then it does an \f(CWmg_get()\fR first.
.RS 4
.Sp
.Vb 1
\& bool  sv_2bool_flags(SV *sv, I32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_clean_all""" 4
.el .IP \f(CWsv_clean_all\fR 4
.IX Xref "sv_clean_all"
.IX Item "sv_clean_all"
Decrement the refcnt of each remaining SV, possibly triggering a
cleanup.  This function may have to be called multiple times to free
SVs which are in complex self-referential hierarchies.
.RS 4
.Sp
.Vb 1
\& SSize_t  sv_clean_all()
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_clean_objs""" 4
.el .IP \f(CWsv_clean_objs\fR 4
.IX Xref "sv_clean_objs"
.IX Item "sv_clean_objs"
Attempt to destroy all objects not yet freed.
.RS 4
.Sp
.Vb 1
\& void  sv_clean_objs()
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_free_arenas""" 4
.el .IP \f(CWsv_free_arenas\fR 4
.IX Xref "sv_free_arenas"
.IX Item "sv_free_arenas"
Deallocate the memory used by all arenas.  Note that all the individual SV
heads and bodies within the arenas must already have been freed.
.RS 4
.Sp
.Vb 1
\& void  sv_free_arenas()
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_grow""" 4
.el .IP \f(CWsv_grow\fR 4
.IX Xref "sv_grow"
.IX Item "sv_grow"
Expands the character buffer in the SV.  If necessary, uses \f(CW\*(C`sv_unref\*(C'\fR and
upgrades the SV to \f(CW\*(C`SVt_PV\*(C'\fR.  Returns a pointer to the character buffer.
Use the \f(CW\*(C`SvGROW\*(C'\fR wrapper instead.
.RS 4
.Sp
.Vb 1
\& char *  sv_grow(SV * const sv, STRLEN newlen)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_grow_fresh""" 4
.el .IP \f(CWsv_grow_fresh\fR 4
.IX Xref "sv_grow_fresh"
.IX Item "sv_grow_fresh"
A cut-down version of sv_grow intended only for when sv is a freshly-minted
SVt_PV, SVt_PVIV, SVt_PVNV, or SVt_PVMG. i.e. sv has the default flags, has
never been any other type, and does not have an existing string. Basically,
just assigns a char buffer and returns a pointer to it.
.RS 4
.Sp
.Vb 1
\& char *  sv_grow_fresh(SV * const sv, STRLEN newlen)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_newref""" 4
.el .IP \f(CWsv_newref\fR 4
.IX Xref "sv_newref"
.IX Item "sv_newref"
Increment an SV's reference count.  Use the \f(CWSvREFCNT_inc()\fR wrapper
instead.
.RS 4
.Sp
.Vb 1
\& SV *  sv_newref(SV * const sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_2num""" 4
.el .IP \f(CWsv_2num\fR 4
.IX Xref "sv_2num"
.IX Item "sv_2num"
NOTE: \f(CW\*(C`sv_2num\*(C'\fR is \fBexperimental\fR and may change or be
removed without notice.
.Sp
Return an SV with the numeric value of the source SV, doing any necessary
reference or overload conversion.  The caller is expected to have handled
get-magic already.
.RS 4
.Sp
.Vb 1
\& SV *  sv_2num(SV * const sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_pv""" 4
.el .IP \f(CWsv_pv\fR 4
.IX Xref "sv_pv"
.IX Item "sv_pv"
Use the \f(CW\*(C`SvPV_nolen\*(C'\fR macro instead
.RS 4
.Sp
.Vb 1
\& char *  sv_pv(SV *sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_pvbyte""" 4
.el .IP \f(CWsv_pvbyte\fR 4
.IX Xref "sv_pvbyte"
.IX Item "sv_pvbyte"
Use \f(CW\*(C`SvPVbyte_nolen\*(C'\fR instead.
.RS 4
.Sp
.Vb 1
\& char *  sv_pvbyte(SV *sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_pvbyten_force""" 4
.el .IP \f(CWsv_pvbyten_force\fR 4
.IX Xref "sv_pvbyten_force"
.IX Item "sv_pvbyten_force"
The backend for the \f(CW\*(C`SvPVbytex_force\*(C'\fR macro.  Always use the macro
instead.  If the SV cannot be downgraded from UTF\-8, this croaks.
.RS 4
.Sp
.Vb 1
\& char *  sv_pvbyten_force(SV * const sv, STRLEN * const lp)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_2pvbyte_nolen""" 4
.el .IP \f(CWsv_2pvbyte_nolen\fR 4
.IX Xref "sv_2pvbyte_nolen"
.IX Item "sv_2pvbyte_nolen"
Return a pointer to the byte-encoded representation of the SV.
May cause the SV to be downgraded from UTF\-8 as a side-effect.
.Sp
Usually accessed via the \f(CW\*(C`SvPVbyte_nolen\*(C'\fR macro.
.RS 4
.Sp
.Vb 1
\& char *  sv_2pvbyte_nolen(SV *sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_pvn_force""" 4
.el .IP \f(CWsv_pvn_force\fR 4
.IX Xref "sv_pvn_force"
.IX Item "sv_pvn_force"
Get a sensible string out of the SV somehow.
A private implementation of the \f(CW\*(C`SvPV_force\*(C'\fR macro for compilers which
can't cope with complex macro expressions.  Always use the macro instead.
.RS 4
.Sp
.Vb 1
\& char *  sv_pvn_force(SV *sv, STRLEN *lp)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_2pv_nolen""" 4
.el .IP \f(CWsv_2pv_nolen\fR 4
.IX Xref "sv_2pv_nolen"
.IX Item "sv_2pv_nolen"
Like \f(CWsv_2pv()\fR, but doesn't return the length too.  You should usually
use the macro wrapper \f(CWSvPV_nolen(sv)\fR instead.
.RS 4
.Sp
.Vb 1
\& char *  sv_2pv_nolen(SV *sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_pvutf8n_force""" 4
.el .IP \f(CWsv_pvutf8n_force\fR 4
.IX Xref "sv_pvutf8n_force"
.IX Item "sv_pvutf8n_force"
The backend for the \f(CW\*(C`SvPVutf8x_force\*(C'\fR macro.  Always use the macro
instead.
.RS 4
.Sp
.Vb 1
\& char *  sv_pvutf8n_force(SV * const sv, STRLEN * const lp)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_2pvutf8_nolen""" 4
.el .IP \f(CWsv_2pvutf8_nolen\fR 4
.IX Xref "sv_2pvutf8_nolen"
.IX Item "sv_2pvutf8_nolen"
Return a pointer to the UTF\-8\-encoded representation of the SV.
May cause the SV to be upgraded to UTF\-8 as a side-effect.
.Sp
Usually accessed via the \f(CW\*(C`SvPVutf8_nolen\*(C'\fR macro.
.RS 4
.Sp
.Vb 1
\& char *  sv_2pvutf8_nolen(SV *sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_pvutf8""" 4
.el .IP \f(CWsv_pvutf8\fR 4
.IX Xref "sv_pvutf8"
.IX Item "sv_pvutf8"
Use the \f(CW\*(C`SvPVutf8_nolen\*(C'\fR macro instead
.RS 4
.Sp
.Vb 1
\& char *  sv_pvutf8(SV *sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_tainted""" 4
.el .IP \f(CWsv_tainted\fR 4
.IX Xref "sv_tainted"
.IX Item "sv_tainted"
Test an SV for taintedness.  Use \f(CW\*(C`SvTAINTED\*(C'\fR instead.
.RS 4
.Sp
.Vb 1
\& bool  sv_tainted(SV * const sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """SvTHINKFIRST""" 4
.el .IP \f(CWSvTHINKFIRST\fR 4
.IX Xref "SvTHINKFIRST"
.IX Item "SvTHINKFIRST"
A quick flag check to see whether an \f(CW\*(C`sv\*(C'\fR should be passed to \f(CW\*(C`sv_force_normal\*(C'\fR
to be "downgraded" before \f(CW\*(C`SvIVX\*(C'\fR or \f(CW\*(C`SvPVX\*(C'\fR can be modified directly.
.Sp
For example, if your scalar is a reference and you want to modify the \f(CW\*(C`SvIVX\*(C'\fR
slot, you can't just do \f(CW\*(C`SvROK_off\*(C'\fR, as that will leak the referent.
.Sp
This is used internally by various sv-modifying functions, such as
\&\f(CW\*(C`sv_setsv\*(C'\fR, \f(CW\*(C`sv_setiv\*(C'\fR and \f(CW\*(C`sv_pvn_force\*(C'\fR.
.Sp
One case that this does not handle is a gv without SvFAKE set.  After
.Sp
.Vb 1
\&    if (SvTHINKFIRST(gv)) sv_force_normal(gv);
.Ve
.Sp
it will still be a gv.
.Sp
\&\f(CW\*(C`SvTHINKFIRST\*(C'\fR sometimes produces false positives.  In those cases
\&\f(CW\*(C`sv_force_normal\*(C'\fR does nothing.
.RS 4
.Sp
.Vb 1
\& U32  SvTHINKFIRST(SV *sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_true""" 4
.el .IP \f(CWsv_true\fR 4
.IX Xref "sv_true"
.IX Item "sv_true"
Returns true if the SV has a true value by Perl's rules.
Use the \f(CW\*(C`SvTRUE\*(C'\fR macro instead, which may call \f(CWsv_true()\fR or may
instead use an in-line version.
.RS 4
.Sp
.Vb 1
\& I32  sv_true(SV * const sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """sv_untaint""" 4
.el .IP \f(CWsv_untaint\fR 4
.IX Xref "sv_untaint"
.IX Item "sv_untaint"
Untaint an SV.  Use \f(CW\*(C`SvTAINTED_off\*(C'\fR instead.
.RS 4
.Sp
.Vb 1
\& void  sv_untaint(SV * const sv)
.Ve
.RE
.RS 4
.RE
.SH Tainting
.IX Header "Tainting"
.ie n .IP """sv_taint""" 4
.el .IP \f(CWsv_taint\fR 4
.IX Xref "sv_taint"
.IX Item "sv_taint"
Taint an SV.  Use \f(CW\*(C`SvTAINTED_on\*(C'\fR instead.
.RS 4
.Sp
.Vb 1
\& void  sv_taint(SV *sv)
.Ve
.RE
.RS 4
.RE
.ie n .IP """TAINT""" 4
.el .IP \f(CWTAINT\fR 4
.IX Xref "TAINT"
.IX Item "TAINT"
If we aren't in taint checking mode, do nothing;
otherwise indicate to "\f(CW\*(C`TAINT_set\*(C'\fR" and "\f(CW\*(C`TAINT_PROPER\*(C'\fR" that some
unspecified element is tainted.
.RS 4
.Sp
.Vb 1
\& void  TAINT()
.Ve
.RE
.RS 4
.RE
.ie n .IP """TAINT_ENV""" 4
.el .IP \f(CWTAINT_ENV\fR 4
.IX Xref "TAINT_ENV"
.IX Item "TAINT_ENV"
Looks at several components of \f(CW%ENV\fR for taintedness, and
calls "\f(CW\*(C`taint_proper\*(C'\fR" if any are tainted.  The components it searches are
things like \f(CW$PATH\fR.
.RS 4
.Sp
.Vb 1
\& void  TAINT_ENV
.Ve
.RE
.RS 4
.RE
.ie n .IP """taint_env""" 4
.el .IP \f(CWtaint_env\fR 4
.IX Xref "taint_env"
.IX Item "taint_env"
Implements the "TAINT_ENV" macro, which you should generally use instead.
.RS 4
.Sp
.Vb 1
\& void  taint_env()
.Ve
.RE
.RS 4
.RE
.ie n .IP """TAINT_get""" 4
.el .IP \f(CWTAINT_get\fR 4
.IX Xref "TAINT_get"
.IX Item "TAINT_get"
Returns a boolean as to whether some element is tainted or not.
.RS 4
.Sp
.Vb 1
\& bool  TAINT_get()
.Ve
.RE
.RS 4
.RE
.ie n .IP """TAINT_IF""" 4
.el .IP \f(CWTAINT_IF\fR 4
.IX Xref "TAINT_IF"
.IX Item "TAINT_IF"
If \f(CW\*(C`c\*(C'\fR evaluates to true, call "\f(CW\*(C`TAINT\*(C'\fR" to indicate that something is
tainted; otherwise do nothing.
.RS 4
.Sp
.Vb 1
\& void  TAINT_IF(bool c)
.Ve
.RE
.RS 4
.RE
.ie n .IP """TAINTING_get""" 4
.el .IP \f(CWTAINTING_get\fR 4
.IX Xref "TAINTING_get"
.IX Item "TAINTING_get"
Returns a boolean as to whether taint checking is enabled or not.
.RS 4
.Sp
.Vb 1
\& bool  TAINTING_get()
.Ve
.RE
.RS 4
.RE
.ie n .IP """TAINTING_set""" 4
.el .IP \f(CWTAINTING_set\fR 4
.IX Xref "TAINTING_set"
.IX Item "TAINTING_set"
Turn taint checking mode off/on
.RS 4
.Sp
.Vb 1
\& void  TAINTING_set(bool s)
.Ve
.RE
.RS 4
.RE
.ie n .IP """TAINT_NOT""" 4
.el .IP \f(CWTAINT_NOT\fR 4
.IX Xref "TAINT_NOT"
.IX Item "TAINT_NOT"
Remove any taintedness previously set by, \fIe.g.\fR, \f(CW\*(C`TAINT\*(C'\fR.
.RS 4
.Sp
.Vb 1
\& void  TAINT_NOT()
.Ve
.RE
.RS 4
.RE
.ie n .IP """TAINT_PROPER""" 4
.el .IP \f(CWTAINT_PROPER\fR 4
.IX Xref "TAINT_PROPER"
.IX Item "TAINT_PROPER"
If no element is tainted, do nothing;
otherwise output a message (containing \f(CW\*(C`s\*(C'\fR) that indicates there is a
tainting violation.  If such violations are fatal, it croaks.
.RS 4
.Sp
.Vb 1
\& void  TAINT_PROPER(const char * s)
.Ve
.RE
.RS 4
.RE
.ie n .IP """taint_proper""" 4
.el .IP \f(CWtaint_proper\fR 4
.IX Xref "taint_proper"
.IX Item "taint_proper"
Implements the "TAINT_PROPER" macro, which you should generally use instead.
.RS 4
.Sp
.Vb 1
\& void  taint_proper(const char *f, const char * const s)
.Ve
.RE
.RS 4
.RE
.ie n .IP """TAINT_set""" 4
.el .IP \f(CWTAINT_set\fR 4
.IX Xref "TAINT_set"
.IX Item "TAINT_set"
If \f(CW\*(C`s\*(C'\fR is true, "\f(CW\*(C`TAINT_get\*(C'\fR" returns true;
If \f(CW\*(C`s\*(C'\fR is false, "\f(CW\*(C`TAINT_get\*(C'\fR" returns false;
.RS 4
.Sp
.Vb 1
\& void  TAINT_set(bool s)
.Ve
.RE
.RS 4
.RE
.ie n .IP """TAINT_WARN_get""" 4
.el .IP \f(CWTAINT_WARN_get\fR 4
.IX Xref "TAINT_WARN_get"
.IX Item "TAINT_WARN_get"
Returns false if tainting violations are fatal;
Returns true if they're just warnings
.RS 4
.Sp
.Vb 1
\& bool  TAINT_WARN_get()
.Ve
.RE
.RS 4
.RE
.ie n .IP """TAINT_WARN_set""" 4
.el .IP \f(CWTAINT_WARN_set\fR 4
.IX Xref "TAINT_WARN_set"
.IX Item "TAINT_WARN_set"
\&\f(CW\*(C`s\*(C'\fR being true indicates "\f(CW\*(C`TAINT_WARN_get\*(C'\fR" should return that tainting
violations are just warnings
.Sp
\&\f(CW\*(C`s\*(C'\fR being false indicates "\f(CW\*(C`TAINT_WARN_get\*(C'\fR" should return that tainting
violations are fatal.
.RS 4
.Sp
.Vb 1
\& void  TAINT_WARN_set(bool s)
.Ve
.RE
.RS 4
.RE
.SH Time
.IX Header "Time"
There are currently no internal API items in Time
.SH "Typedef names"
.IX Header "Typedef names"
There are currently no internal API items in Typedef names
.SH "Unicode Support"
.IX Xref "FOLDEQ_LOCALE FOLDEQ_S1_ALREADY_FOLDED FOLDEQ_S1_FOLDS_SANE FOLDEQ_S2_ALREADY_FOLDED FOLDEQ_S2_FOLDS_SANE FOLDEQ_UTF8_NOMIX_ASCII"
.IX Header "Unicode Support"
.ie n .IP """bytes_from_utf8_loc""" 4
.el .IP \f(CWbytes_from_utf8_loc\fR 4
.IX Xref "bytes_from_utf8_loc"
.IX Item "bytes_from_utf8_loc"
NOTE: \f(CW\*(C`bytes_from_utf8_loc\*(C'\fR is \fBexperimental\fR and may change or be
removed without notice.
.Sp
Like \f(CW\*(C`"bytes_from_utf8" in perlapi()\*(C'\fR, but takes an extra parameter, a pointer
to where to store the location of the first character in \f(CW"s"\fR that cannot be
converted to non\-UTF8.
.Sp
If that parameter is \f(CW\*(C`NULL\*(C'\fR, this function behaves identically to
\&\f(CW\*(C`bytes_from_utf8\*(C'\fR.
.Sp
Otherwise if \f(CW*is_utf8p\fR is 0 on input, the function behaves identically to
\&\f(CW\*(C`bytes_from_utf8\*(C'\fR, except it also sets \f(CW*first_non_downgradable\fR to \f(CW\*(C`NULL\*(C'\fR.
.Sp
Otherwise, the function returns a newly created \f(CW\*(C`NUL\*(C'\fR\-terminated string
containing the non\-UTF8 equivalent of the convertible first portion of
\&\f(CW"s"\fR.  \f(CW*lenp\fR is set to its length, not including the terminating \f(CW\*(C`NUL\*(C'\fR.
If the entire input string was converted, \f(CW*is_utf8p\fR is set to a FALSE value,
and \f(CW*first_non_downgradable\fR is set to \f(CW\*(C`NULL\*(C'\fR.
.Sp
Otherwise, \f(CW*first_non_downgradable\fR is set to point to the first byte of the
first character in the original string that wasn't converted.  \f(CW*is_utf8p\fR is
unchanged.  Note that the new string may have length 0.
.Sp
Another way to look at it is, if \f(CW*first_non_downgradable\fR is non\-\f(CW\*(C`NULL\*(C'\fR and
\&\f(CW*is_utf8p\fR is TRUE, this function starts at the beginning of \f(CW"s"\fR and
converts as many characters in it as possible stopping at the first one it
finds that can't be converted to non\-UTF\-8.  \f(CW*first_non_downgradable\fR is
set to point to that.  The function returns the portion that could be converted
in a newly created \f(CW\*(C`NUL\*(C'\fR\-terminated string, and \f(CW*lenp\fR is set to its length,
not including the terminating \f(CW\*(C`NUL\*(C'\fR.  If the very first character in the
original could not be converted, \f(CW*lenp\fR will be 0, and the new string will
contain just a single \f(CW\*(C`NUL\*(C'\fR.  If the entire input string was converted,
\&\f(CW*is_utf8p\fR is set to FALSE and \f(CW*first_non_downgradable\fR is set to \f(CW\*(C`NULL\*(C'\fR.
.Sp
Upon successful return, the number of variants in the converted portion of the
string can be computed by having saved the value of \f(CW*lenp\fR before the call,
and subtracting the after-call value of \f(CW*lenp\fR from it.
.RS 4
.Sp
.Vb 3
\& U8 *  bytes_from_utf8_loc(const U8 *s, STRLEN *lenp,
\&                           bool *is_utf8p,
\&                           const U8 **first_unconverted)
.Ve
.RE
.RS 4
.RE
.ie n .IP """find_uninit_var""" 4
.el .IP \f(CWfind_uninit_var\fR 4
.IX Xref "find_uninit_var"
.IX Item "find_uninit_var"
NOTE: \f(CW\*(C`find_uninit_var\*(C'\fR is \fBexperimental\fR and may change or be
removed without notice.
.Sp
Find the name of the undefined variable (if any) that caused the operator
to issue a "Use of uninitialized value" warning.
If match is true, only return a name if its value matches \f(CW\*(C`uninit_sv\*(C'\fR.
So roughly speaking, if a unary operator (such as \f(CW\*(C`OP_COS\*(C'\fR) generates a
warning, then following the direct child of the op may yield an
\&\f(CW\*(C`OP_PADSV\*(C'\fR or \f(CW\*(C`OP_GV\*(C'\fR that gives the name of the undefined variable.  On the
other hand, with \f(CW\*(C`OP_ADD\*(C'\fR there are two branches to follow, so we only print
the variable name if we get an exact match.
\&\f(CW\*(C`desc_p\*(C'\fR points to a string pointer holding the description of the op.
This may be updated if needed.
.Sp
The name is returned as a mortal SV.
.Sp
Assumes that \f(CW\*(C`PL_op\*(C'\fR is the OP that originally triggered the error, and that
\&\f(CW\*(C`PL_comppad\*(C'\fR/\f(CW\*(C`PL_curpad\*(C'\fR points to the currently executing pad.
.RS 4
.Sp
.Vb 3
\& SV *  find_uninit_var(const OP * const obase,
\&                       const SV * const uninit_sv, bool match,
\&                       const char **desc_p)
.Ve
.RE
.RS 4
.RE
.ie n .IP """isSCRIPT_RUN""" 4
.el .IP \f(CWisSCRIPT_RUN\fR 4
.IX Xref "isSCRIPT_RUN"
.IX Item "isSCRIPT_RUN"
Returns a bool as to whether or not the sequence of bytes from \f(CW\*(C`s\*(C'\fR up to but
not including \f(CW\*(C`send\*(C'\fR form a "script run".  \f(CW\*(C`utf8_target\*(C'\fR is TRUE iff the
sequence starting at \f(CW\*(C`s\*(C'\fR is to be treated as UTF\-8.  To be precise, except for
two degenerate cases given below, this function returns TRUE iff all code
points in it come from any combination of three "scripts" given by the Unicode
"Script Extensions" property: Common, Inherited, and possibly one other.
Additionally all decimal digits must come from the same consecutive sequence of
10.
.Sp
For example, if all the characters in the sequence are Greek, or Common, or
Inherited, this function will return TRUE, provided any decimal digits in it
are from the same block of digits in Common.  (These are the ASCII digits
"0".."9" and additionally a block for full width forms of these, and several
others used in mathematical notation.)   For scripts (unlike Greek) that have
their own digits defined this will accept either digits from that set or from
one of the Common digit sets, but not a combination of the two.  Some scripts,
such as Arabic, have more than one set of digits.  All digits must come from
the same set for this function to return TRUE.
.Sp
\&\f(CW*ret_script\fR, if \f(CW\*(C`ret_script\*(C'\fR is not NULL, will on return of TRUE
contain the script found, using the \f(CW\*(C`SCX_enum\*(C'\fR typedef.  Its value will be
\&\f(CW\*(C`SCX_INVALID\*(C'\fR if the function returns FALSE.
.Sp
If the sequence is empty, TRUE is returned, but \f(CW*ret_script\fR (if asked for)
will be \f(CW\*(C`SCX_INVALID\*(C'\fR.
.Sp
If the sequence contains a single code point which is unassigned to a character
in the version of Unicode being used, the function will return TRUE, and the
script will be \f(CW\*(C`SCX_Unknown\*(C'\fR.  Any other combination of unassigned code points
in the input sequence will result in the function treating the input as not
being a script run.
.Sp
The returned script will be \f(CW\*(C`SCX_Inherited\*(C'\fR iff all the code points in it are
from the Inherited script.
.Sp
Otherwise, the returned script will be \f(CW\*(C`SCX_Common\*(C'\fR iff all the code points in
it are from the Inherited or Common scripts.
.RS 4
.Sp
.Vb 2
\& bool  isSCRIPT_RUN(const U8 *s, const U8 *send,
\&                    const bool utf8_target)
.Ve
.RE
.RS 4
.RE
.ie n .IP """is_utf8_non_invariant_string""" 4
.el .IP \f(CWis_utf8_non_invariant_string\fR 4
.IX Xref "is_utf8_non_invariant_string"
.IX Item "is_utf8_non_invariant_string"
Returns TRUE if "is_utf8_invariant_string" in perlapi returns FALSE for the first
\&\f(CW\*(C`len\*(C'\fR bytes of the string \f(CW\*(C`s\*(C'\fR, but they are, nonetheless, legal Perl-extended
UTF\-8; otherwise returns FALSE.
.Sp
A TRUE return means that at least one code point represented by the sequence
either is a wide character not representable as a single byte, or the
representation differs depending on whether the sequence is encoded in UTF\-8 or
not.
.Sp
See also
\&\f(CW\*(C`"is_utf8_invariant_string" in perlapi\*(C'\fR,
\&\f(CW\*(C`"is_utf8_string" in perlapi\*(C'\fR
.RS 4
.Sp
.Vb 1
\& bool  is_utf8_non_invariant_string(const U8 * const s, STRLEN len)
.Ve
.RE
.RS 4
.RE
.ie n .IP """utf8n_to_uvuni""" 4
.el .IP \f(CWutf8n_to_uvuni\fR 4
.IX Xref "utf8n_to_uvuni"
.IX Item "utf8n_to_uvuni"
\&\f(CW\*(C`\fR\f(CBDEPRECATED!\fR\f(CW\*(C'\fR  It is planned to remove \f(CW\*(C`utf8n_to_uvuni\*(C'\fR
from a future release of Perl.  Do not use it for
new code; remove it from existing code.
.Sp
Instead use "utf8_to_uvchr_buf" in perlapi, or rarely, "utf8n_to_uvchr" in perlapi.
.Sp
This function was useful for code that wanted to handle both EBCDIC and
ASCII platforms with Unicode properties, but starting in Perl v5.20, the
distinctions between the platforms have mostly been made invisible to most
code, so this function is quite unlikely to be what you want.  If you do need
this precise functionality, use instead
\&\f(CW\*(C`NATIVE_TO_UNI(utf8_to_uvchr_buf(...))\*(C'\fR
or \f(CW\*(C`NATIVE_TO_UNI(utf8n_to_uvchr(...))\*(C'\fR.
.RS 4
.Sp
.Vb 2
\& UV  utf8n_to_uvuni(const U8 *s, STRLEN curlen, STRLEN *retlen,
\&                    U32 flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """utf8_to_uvuni""" 4
.el .IP \f(CWutf8_to_uvuni\fR 4
.IX Xref "utf8_to_uvuni"
.IX Item "utf8_to_uvuni"
\&\f(CW\*(C`\fR\f(CBDEPRECATED!\fR\f(CW\*(C'\fR  It is planned to remove \f(CW\*(C`utf8_to_uvuni\*(C'\fR
from a future release of Perl.  Do not use it for
new code; remove it from existing code.
.Sp
Returns the Unicode code point of the first character in the string \f(CW\*(C`s\*(C'\fR
which is assumed to be in UTF\-8 encoding; \f(CW\*(C`retlen\*(C'\fR will be set to the
length, in bytes, of that character.
.Sp
Some, but not all, UTF\-8 malformations are detected, and in fact, some
malformed input could cause reading beyond the end of the input buffer, which
is one reason why this function is deprecated.  The other is that only in
extremely limited circumstances should the Unicode versus native code point be
of any interest to you.
.Sp
If \f(CW\*(C`s\*(C'\fR points to one of the detected malformations, and UTF8 warnings are
enabled, zero is returned and \f(CW*retlen\fR is set (if \f(CW\*(C`retlen\*(C'\fR doesn't point to
NULL) to \-1.  If those warnings are off, the computed value if well-defined (or
the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and \f(CW*retlen\fR
is set (if \f(CW\*(C`retlen\*(C'\fR isn't NULL) so that (\f(CW\*(C`s\*(C'\fR\ +\ \f(CW*retlen\fR) is the
next possible position in \f(CW\*(C`s\*(C'\fR that could begin a non-malformed character.
See "utf8n_to_uvchr" in perlapi for details on when the REPLACEMENT CHARACTER is returned.
.RS 4
.Sp
.Vb 1
\& UV  utf8_to_uvuni(const U8 *s, STRLEN *retlen)
.Ve
.RE
.RS 4
.RE
.ie n .IP """uvoffuni_to_utf8_flags""" 4
.el .IP \f(CWuvoffuni_to_utf8_flags\fR 4
.IX Xref "uvoffuni_to_utf8_flags"
.IX Item "uvoffuni_to_utf8_flags"
THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.
Instead, \fBAlmost all code should use "uvchr_to_utf8" in perlapi or
"uvchr_to_utf8_flags" in perlapi\fR.
.Sp
This function is like them, but the input is a strict Unicode
(as opposed to native) code point.  Only in very rare circumstances should code
not be using the native code point.
.Sp
For details, see the description for "uvchr_to_utf8_flags" in perlapi.
.RS 4
.Sp
.Vb 1
\& U8 *  uvoffuni_to_utf8_flags(U8 *d, UV uv, UV flags)
.Ve
.RE
.RS 4
.RE
.ie n .IP """valid_utf8_to_uvchr""" 4
.el .IP \f(CWvalid_utf8_to_uvchr\fR 4
.IX Xref "valid_utf8_to_uvchr"
.IX Item "valid_utf8_to_uvchr"
Like \f(CW\*(C`"utf8_to_uvchr_buf" in perlapi\*(C'\fR, but should only be called when it is
known that the next character in the input UTF\-8 string \f(CW\*(C`s\*(C'\fR is well-formed
(\fIe.g.\fR, it passes \f(CW\*(C`"isUTF8_CHAR" in perlapi\*(C'\fR.  Surrogates, non-character code
points, and non-Unicode code points are allowed.
.RS 4
.Sp
.Vb 1
\& UV  valid_utf8_to_uvchr(const U8 *s, STRLEN *retlen)
.Ve
.RE
.RS 4
.RE
.ie n .IP """variant_under_utf8_count""" 4
.el .IP \f(CWvariant_under_utf8_count\fR 4
.IX Xref "variant_under_utf8_count"
.IX Item "variant_under_utf8_count"
This function looks at the sequence of bytes between \f(CW\*(C`s\*(C'\fR and \f(CW\*(C`e\*(C'\fR, which are
assumed to be encoded in ASCII/Latin1, and returns how many of them would
change should the string be translated into UTF\-8.  Due to the nature of UTF\-8,
each of these would occupy two bytes instead of the single one in the input
string.  Thus, this function returns the precise number of bytes the string
would expand by when translated to UTF\-8.
.Sp
Unlike most of the other functions that have \f(CW\*(C`utf8\*(C'\fR in their name, the input
to this function is NOT a UTF\-8\-encoded string.  The function name is slightly
\&\fIodd\fR to emphasize this.
.Sp
This function is internal to Perl because khw thinks that any XS code that
would want this is probably operating too close to the internals.  Presenting a
valid use case could change that.
.Sp
See also
\&\f(CW\*(C`"is_utf8_invariant_string" in perlapi\*(C'\fR
and
\&\f(CW\*(C`"is_utf8_invariant_string_loc" in perlapi\*(C'\fR,
.RS 4
.Sp
.Vb 2
\& Size_t  variant_under_utf8_count(const U8 * const s,
\&                                  const U8 * const e)
.Ve
.RE
.RS 4
.RE
.SH "Utility Functions"
.IX Header "Utility Functions"
.ie n .IP """my_popen_list""" 4
.el .IP \f(CWmy_popen_list\fR 4
.IX Xref "my_popen_list"
.IX Item "my_popen_list"
Implementing function on some systems for \fBPerlProc_popen_list()\fR
.RS 4
.Sp
.Vb 1
\& PerlIO *  my_popen_list(const char *mode, int n, SV **args)
.Ve
.RE
.RS 4
.RE
.ie n .IP """my_socketpair""" 4
.el .IP \f(CWmy_socketpair\fR 4
.IX Xref "my_socketpair"
.IX Item "my_socketpair"
Emulates \fBsocketpair\fR\|(2) on systems that don't have it, but which do have
enough functionality for the emulation.
.RS 4
.Sp
.Vb 1
\& int  my_socketpair(int family, int type, int protocol, int fd[2])
.Ve
.RE
.RS 4
.RE
.SH Versioning
.IX Header "Versioning"
There are currently no internal API items in Versioning
.SH "Warning and Dieing"
.IX Header "Warning and Dieing"
.ie n .IP """deprecate""" 4
.el .IP \f(CWdeprecate\fR 4
.IX Xref "deprecate"
.IX Item "deprecate"
Wrapper around \fBPerl_ck_warner_d()\fR to produce a deprecated warning in the
given category with an appropriate message. The \f(CW\*(C`message\*(C'\fR argument must
be a C string. The string " is deprecated" will automatically be added
to the end of the \f(CW\*(C`message\*(C'\fR.
.RS 4
.Sp
.Vb 1
\&   deprecate(U32 category, "message")
.Ve
.RE
.RS 4
.RE
.ie n .IP """deprecate_disappears_in""" 4
.el .IP \f(CWdeprecate_disappears_in\fR 4
.IX Xref "deprecate_disappears_in"
.IX Item "deprecate_disappears_in"
Wrapper around \fBPerl_ck_warner_d()\fR to produce a deprecated warning in the
given category with an appropriate message that the construct referred
to by the message will disappear in a specific release.  The \f(CW\*(C`when\*(C'\fR and
\&\f(CW\*(C`message\*(C'\fR arguments must be a C string.  The \f(CW\*(C`when\*(C'\fR string is expected
to be of the form "5.40", with no minor element in the version.  The actual
message output will be the result of the following expression \f(CW\*(C`message
" is deprecated, and will disappear in Perl " when\*(C'\fR which is why \f(CW\*(C`message\*(C'\fR
and \f(CW\*(C`when\*(C'\fR must be literal C strings.
.RS 4
.Sp
.Vb 1
\&   deprecate_disappears_in(U32 category, "when", "message")
.Ve
.RE
.RS 4
.RE
.ie n .IP """deprecate_fatal_in""" 4
.el .IP \f(CWdeprecate_fatal_in\fR 4
.IX Xref "deprecate_fatal_in"
.IX Item "deprecate_fatal_in"
Wrapper around \fBPerl_ck_warner_d()\fR to produce a deprecated warning in the
given category with an appropriate message that the construct referred
to by the message will become fatal in a specific release.  The \f(CW\*(C`when\*(C'\fR
and \f(CW\*(C`message\*(C'\fR arguments must be a C string.  The \f(CW\*(C`when\*(C'\fR string is expected
to be of the form "5.40", with no minor element in the version.  The actual
message output will be the result of the following expression \f(CW\*(C`message " is
deprecated, and will become fatal in Perl " when\*(C'\fR which is why \f(CW\*(C`message\*(C'\fR
and \f(CW\*(C`when\*(C'\fR must be literal C strings.
.RS 4
.Sp
.Vb 1
\&   deprecate_fatal_in(U32 category, "when", "message")
.Ve
.RE
.RS 4
.RE
.ie n .IP """PL_dowarn""" 4
.el .IP \f(CWPL_dowarn\fR 4
.IX Xref "PL_dowarn"
.IX Item "PL_dowarn"
The C variable that roughly corresponds to Perl's \f(CW$^W\fR warning variable.
However, \f(CW$^W\fR is treated as a boolean, whereas \f(CW\*(C`PL_dowarn\*(C'\fR is a
collection of flag bits.
.Sp
On threaded perls, each thread has an independent copy of this variable;
each initialized at creation time with the current value of the creating
thread's copy.
.RS 4
.Sp
.Vb 1
\& U8  PL_dowarn
.Ve
.RE
.RS 4
.RE
.ie n .IP """report_uninit""" 4
.el .IP \f(CWreport_uninit\fR 4
.IX Xref "report_uninit"
.IX Item "report_uninit"
Print appropriate "Use of uninitialized variable" warning.
.RS 4
.Sp
.Vb 1
\& void  report_uninit(const SV *uninit_sv)
.Ve
.RE
.RS 4
.RE
.SH XS
.IX Header "XS"
There are currently no internal API items in XS
.SH "Undocumented elements"
.IX Header "Undocumented elements"
This section lists the elements that are otherwise undocumented.  If you use
any of them, please consider creating and submitting documentation for it.
.PP
Experimental and deprecated undocumented elements are listed separately at the
end.
.PP

.IX Xref "abort_execution add_above_Latin1_folds add_cp_to_invlist _add_range_to_invlist allocmy amagic_cmp amagic_cmp_desc amagic_cmp_locale amagic_cmp_locale_desc amagic_i_ncmp amagic_i_ncmp_desc amagic_is_enabled amagic_ncmp amagic_ncmp_desc any_dup append_utf8_from_native_byte apply atfork_lock atfork_unlock av_arylen_p av_extend_guts av_iter_p av_nonelem av_reify bind_match block_gimme boot_core_builtin boot_core_mro boot_core_PerlIO boot_core_UNIVERSAL build_infix_plugin _byte_dump_string call_list cando capture_clear cast_iv cast_i32 cast_ulong cast_uv check_hash_fields_and_hekify check_regnode_after check_utf8_print ck_anoncode ck_backtick ck_bitop ck_classname ck_cmp ck_concat ck_defined ck_delete ck_each ck_entersub_args_core ck_eof ck_eval ck_exec ck_exists ck_ftst ck_fun ck_glob ck_grep ck_helemexistsor ck_index ck_isa ck_join ck_length ck_lfun ck_listiob ck_match ck_method ck_null ck_open ck_prototype ck_readline ck_refassign ck_repeat ck_require ck_return ck_rfun ck_rvconst ck_sassign ck_select ck_shift ck_smartmatch ck_sort ck_spair ck_split ck_stringify ck_subr ck_substr ck_svconst ck_tell ck_trunc ck_trycatch ckwarn ckwarn_d class_add_ADJUST class_add_field class_apply_attributes class_apply_field_attributes class_prepare_initfield_parse class_prepare_method_parse class_seal_stash class_set_field_defop class_setup_stash class_wrap_method_body clear_defarray closest_cop cmpchain_extend cmpchain_finish cmpchain_start cmp_desc cmp_locale_desc cntrl_to_mnemonic construct_ahocorasick_from_trie cop_file_avn coresub_op croak_caller croak_kw_unless_class croak_memory_wrap croak_no_mem croak_no_mem_ext croak_popstack csighandler csighandler1 csighandler3 current_re_engine custom_op_get_field cv_clone_into cv_const_sv_or_av cvgv_from_hek cvgv_set cvstash_set cv_undef_flags cx_dump cx_dup cxinc deb_stack_all debstackptrs debug_hash_seed debug_peep debug_show_study_flags debug_studydata defelem_target despatch_signals die_unwind do_aexec do_aexec5 do_aspawn do_eof does_utf8_overflow do_exec do_exec3 dofile do_gv_dump do_gvgv_dump do_hv_dump doing_taint do_ipcctl do_ipcget do_magic_dump do_msgrcv do_msgsnd do_ncmp do_op_dump do_pmop_dump do_print do_readline doref do_seek do_semop do_shmio do_spawn do_spawn_nowait do_sv_dump do_sysseek do_tell do_trans do_uniprop_match do_vecget do_vecset do_vop drand48_init_r drand48_r dtrace_probe_call dtrace_probe_load dtrace_probe_op dtrace_probe_phase dump_all_perl dump_indent dump_packsubs_perl dump_sub_perl dump_sv_child dumpuntil dump_vindent dup_warnings find_first_differing_byte_pos find_lexical_cv find_runcv_where find_script finish_export_lexical foldEQ_latin1_s2_folded foldEQ_latin1 foldEQ_utf8_flags force_locale_unlock _force_out_malformed_utf8_message form_alien_digit_msg form_cp_too_large_msg free_tied_hv_pool free_tmps get_and_check_backslash_N_name get_ANYOFHbbm_contents get_ANYOFM_contents get_db_sub get_debug_opts get_deprecated_property_msg getenv_len get_extended_os_errno get_hash_seed get_invlist_iter_addr get_invlist_offset_addr get_invlist_previous_index_addr get_mstats get_prop_definition get_prop_values get_regclass_aux_data get_re_gclass_aux_data get_regex_charset_name get_win32_message_utf8ness gp_free gp_ref grok_bin_oct_hex grok_bslash_c grok_bslash_o grok_bslash_x gv_check gv_fetchmeth_internal gv_override gv_setref gv_stashpvn_internal he_dup hek_dup hfree_next_entry hv_auxalloc hv_common hv_common_key_len hv_delayfree_ent hv_free_ent hv_placeholders_p hv_pushkv hv_rand_set hv_undef_flags import_builtin_bundle infix_plugin_standard init_argv_symbols init_constants init_dbargs init_debugger init_i18nl10n init_named_cv init_stacks init_tm init_uniprops _inverse_folds invert invlist_array _invlist_array_init invlist_clear invlist_clone _invlist_contains_cp invlist_contents _invlist_dump _invlistEQ invlist_extend invlist_highest _invlist_intersection _invlist_intersection_maybe_complement_2nd _invlist_invert invlist_is_iterating invlist_iterfinish invlist_iterinit invlist_iternext _invlist_len invlist_max invlist_previous_index _invlist_search invlist_set_len invlist_set_previous_index _invlist_subtract invlist_trim _invlist_union _invlist_union_maybe_complement_2nd invmap_dump invoke_exception_hook io_close isFF_overlong is_grapheme _is_in_locale_category is_invlist is_standard_filehandle_name _is_uni_FOO _is_uni_perl_idcont _is_uni_perl_idstart is_utf8_char_helper_ is_utf8_common is_utf8_FF_helper_ _is_utf8_FOO is_utf8_overlong _is_utf8_perl_idcont _is_utf8_perl_idstart jmaybe join_exact keyword keyword_plugin_standard list load_charnames locale_panic localize lossless_NV_to_IV lsbit_pos32 lsbit_pos64 magic_clear_all_env magic_cleararylen_p magic_clearenv magic_clearhook magic_clearhookall magic_clearisa magic_clearpack magic_clearsig magic_copycallchecker magic_existspack magic_freearylen_p magic_freecollxfrm magic_freemglob magic_freeovrld magic_freeutf8 magic_get magic_getarylen magic_getdebugvar magic_getdefelem magic_getnkeys magic_getpack magic_getpos magic_getsig magic_getsubstr magic_gettaint magic_getuvar magic_getvec magic_killbackrefs magic_nextpack magic_regdata_cnt magic_regdatum_get magic_regdatum_set magic_scalarpack magic_set magic_set_all_env magic_setarylen magic_setcollxfrm magic_setdbline magic_setdebugvar magic_setdefelem magic_setenv magic_sethook magic_sethookall magic_setisa magic_setlvref magic_setmglob magic_setnkeys magic_setnonelem magic_setpack magic_setpos magic_setregexp magic_setsig magic_setsigall magic_setsubstr magic_settaint magic_setutf8 magic_setuvar magic_setvec magic_sizepack magic_wipepack make_trie malloced_size malloc_good_size markstack_grow mbtowc_ mem_collxfrm_ mem_log_alloc mem_log_del_sv mem_log_free mem_log_new_sv mem_log_realloc mg_find_mglob mg_size mode_from_discipline more_bodies more_sv moreswitches mortal_getenv mortalized_pv_copy mro_get_private_data mro_meta_dup mro_meta_init msbit_pos32 msbit_pos64 multiconcat_stringify multideref_stringify my_atof2 my_atof3 my_attrs my_clearenv my_lstat my_lstat_flags my_memrchr my_mkostemp_cloexec my_mkstemp_cloexec my_stat my_stat_flags my_strerror my_unexec newFORM _new_invlist _new_invlist_C_array newMETHOP_internal newPROG new_stackinfo new_stackinfo_flags newSTUB newSVavdefelem newXS_deffile nextargv no_bareword_allowed no_bareword_filehandle noperl_die notify_parser_that_changed_to_utf8 oopsAV oopsHV op_clear op_integerize op_lvalue_flags opmethod_stash op_prune_chain_head op_relocate_sv opslab_force_free opslab_free opslab_free_nopad op_std_init op_varname package package_version pad_add_weakref padlist_store padname_free PadnameIN_SCOPE padnamelist_free parser_dup parser_free parser_free_nexttoke_ops parse_unicode_opts path_is_searchable peep perl_alloc_using perl_clone_using PerlEnv_putenv PerlIO_context_layers PerlIO_restore_errno PerlIO_save_errno PerlLIO_dup_cloexec PerlLIO_dup2_cloexec PerlLIO_open_cloexec PerlLIO_open3_cloexec PerlProc_pipe_cloexec PerlSock_accept_cloexec PerlSock_socket_cloexec PerlSock_socketpair_cloexec perly_sighandler pmruntime POPMARK populate_anyof_bitmap_from_invlist populate_bitmap_from_invlist populate_invlist_from_bitmap populate_isa pregfree pregfree2 prepare_export_lexical ptr_hash qerror ReANY reentrant_free reentrant_init reentrant_retry reentrant_size re_exec_indentf ref reg_add_data regcurly regdump regdupe_internal regexec_flags regfree_internal reginitcolors reg_named_buff reg_named_buff_all reg_named_buff_exists reg_named_buff_fetch reg_named_buff_firstkey reg_named_buff_iter reg_named_buff_nextkey reg_named_buff_scalar regnext regnode_after reg_numbered_buff_fetch reg_numbered_buff_fetch_flags reg_numbered_buff_length reg_numbered_buff_store regprop reg_qr_package reg_skipcomment reg_temp_copy re_indentf re_intuit_start re_intuit_string re_op_compile report_evil_fh report_redefined_cv report_wrongway_fh re_printf rpeep rsignal_restore rsignal_save rvpv_dup rxres_save same_dirent save_bool save_clearsv save_delete save_destructor save_destructor_x save_freeop save_freepv save_freesv save_int save_iv save_I8 save_I16 save_I32 save_mortalizesv save_pptr save_pushi32ptr save_pushptrptr save_re_context save_sptr savestack_grow savestack_grow_cnt save_strlen sawparens scalar scalarvoid scan_commit scan_num seed set_ANYOF_arg set_caret_X setfd_cloexec setfd_cloexec_for_nonsysfd setfd_cloexec_or_inhexec_by_sysfdness setfd_inhexec setfd_inhexec_for_sysfd set_numeric_standard set_numeric_underlying set_padlist _setup_canned_invlist share_hek should_warn_nl should_we_output_Debug_r sighandler sighandler1 sighandler3 single_1bit_pos32 single_1bit_pos64 Slab_Alloc Slab_Free Slab_to_ro Slab_to_rw softref2xv sortsv_flags_impl ssc_init stack_grow str_to_version strxfrm study_chunk sub_crush_depth sv_add_backref sv_buf_to_ro sv_del_backref sv_i_ncmp sv_i_ncmp_desc sv_2iv sv_magicext_mglob sv_mark_arenas sv_ncmp sv_ncmp_desc sv_only_taint_gmagic sv_or_pv_pos_u2b sv_pvbyten_force_wrapper sv_pvutf8n_force_wrapper sv_resetpvn sv_sethek sv_sweep_arenas SvTRUE_common sv_unglob sv_2uv switch_locale_context sys_init sys_init3 sys_intern_clear sys_intern_dup sys_intern_init sys_term tied_method tmps_grow_p _to_fold_latin1 TOPMARK to_uni_fold _to_uni_fold_flags to_uni_lower to_uni_title to_uni_upper _to_upper_title_latin1 _to_utf8_fold_flags _to_utf8_lower_flags _to_utf8_title_flags _to_utf8_upper_flags translate_substr_offsets try_amagic_bin try_amagic_un uiv_2buf unlnk unshare_hek unwind_paren _utf8n_to_uvchr_msgs_helper utf16_to_utf8_base utf16_to_utf8_reversed utf16_to_utf8 utf8_to_uvchr_buf_helper utilize uvoffuni_to_utf8_flags_msgs variant_byte_number varname vivify_defelem vivify_ref wait4pid warn_elem_scalar_context warn_problematic_locale was_lvalue_sub watch win32_croak_not_implemented write_to_stderr xs_boot_epilog xs_handshake yyerror yyerror_pv yyerror_pvn yylex yyparse yyquit yyunlex"
.PP
.Vb 10
\& abort_execution
\& add_above_Latin1_folds
\& add_cp_to_invlist
\& _add_range_to_invlist
\& allocmy
\& amagic_cmp
\& amagic_cmp_desc
\& amagic_cmp_locale
\& amagic_cmp_locale_desc
\& amagic_i_ncmp
\& amagic_i_ncmp_desc
\& amagic_is_enabled
\& amagic_ncmp
\& amagic_ncmp_desc
\& any_dup
\& append_utf8_from_native_byte
\& apply
\& atfork_lock
\& atfork_unlock
\& av_arylen_p
\& av_extend_guts
\& av_iter_p
\& av_nonelem
\& av_reify
\& bind_match
\& block_gimme
\& boot_core_builtin
\& boot_core_mro
\& boot_core_PerlIO
\& boot_core_UNIVERSAL
\& build_infix_plugin
\& _byte_dump_string
\& call_list
\& cando
\& capture_clear
\& cast_iv
\& cast_i32
\& cast_ulong
\& cast_uv
\& check_hash_fields_and_hekify
\& check_regnode_after
\& check_utf8_print
\& ck_anoncode
\& ck_backtick
\& ck_bitop
\& ck_classname
\& ck_cmp
\& ck_concat
\& ck_defined
\& ck_delete
\& ck_each
\& ck_entersub_args_core
\& ck_eof
\& ck_eval
\& ck_exec
\& ck_exists
\& ck_ftst
\& ck_fun
\& ck_glob
\& ck_grep
\& ck_helemexistsor
\& ck_index
\& ck_isa
\& ck_join
\& ck_length
\& ck_lfun
\& ck_listiob
\& ck_match
\& ck_method
\& ck_null
\& ck_open
\& ck_prototype
\& ck_readline
\& ck_refassign
\& ck_repeat
\& ck_require
\& ck_return
\& ck_rfun
\& ck_rvconst
\& ck_sassign
\& ck_select
\& ck_shift
\& ck_smartmatch
\& ck_sort
\& ck_spair
\& ck_split
\& ck_stringify
\& ck_subr
\& ck_substr
\& ck_svconst
\& ck_tell
\& ck_trunc
\& ck_trycatch
\& ckwarn
\& ckwarn_d
\& class_add_ADJUST
\& class_add_field
\& class_apply_attributes
\& class_apply_field_attributes
\& class_prepare_initfield_parse
\& class_prepare_method_parse
\& class_seal_stash
\& class_set_field_defop
\& class_setup_stash
\& class_wrap_method_body
\& clear_defarray
\& closest_cop
\& cmpchain_extend
\& cmpchain_finish
\& cmpchain_start
\& cmp_desc
\& cmp_locale_desc
\& cntrl_to_mnemonic
\& construct_ahocorasick_from_trie
\& cop_file_avn
\& coresub_op
\& croak_caller
\& croak_kw_unless_class
\& croak_memory_wrap
\& croak_no_mem
\& croak_no_mem_ext
\& croak_popstack
\& csighandler
\& csighandler1
\& csighandler3
\& current_re_engine
\& custom_op_get_field
\& cv_clone_into
\& cv_const_sv_or_av
\& cvgv_from_hek
\& cvgv_set
\& cvstash_set
\& cv_undef_flags
\& cx_dump
\& cx_dup
\& cxinc
\& deb_stack_all
\& debstackptrs
\& debug_hash_seed
\& debug_peep
\& debug_show_study_flags
\& debug_studydata
\& defelem_target
\& despatch_signals
\& die_unwind
\& do_aexec
\& do_aexec5
\& do_aspawn
\& do_eof
\& does_utf8_overflow
\& do_exec
\& do_exec3
\& dofile
\& do_gv_dump
\& do_gvgv_dump
\& do_hv_dump
\& doing_taint
\& do_ipcctl
\& do_ipcget
\& do_magic_dump
\& do_msgrcv
\& do_msgsnd
\& do_ncmp
\& do_op_dump
\& do_pmop_dump
\& do_print
\& do_readline
\& doref
\& do_seek
\& do_semop
\& do_shmio
\& do_spawn
\& do_spawn_nowait
\& do_sv_dump
\& do_sysseek
\& do_tell
\& do_trans
\& do_uniprop_match
\& do_vecget
\& do_vecset
\& do_vop
\& drand48_init_r
\& drand48_r
\& dtrace_probe_call
\& dtrace_probe_load
\& dtrace_probe_op
\& dtrace_probe_phase
\& dump_all_perl
\& dump_indent
\& dump_packsubs_perl
\& dump_sub_perl
\& dump_sv_child
\& dumpuntil
\& dump_vindent
\& dup_warnings
\& find_first_differing_byte_pos
\& find_lexical_cv
\& find_runcv_where
\& find_script
\& finish_export_lexical
\& foldEQ_latin1_s2_folded
\& foldEQ_latin1
\& foldEQ_utf8_flags
\& force_locale_unlock
\& _force_out_malformed_utf8_message
\& form_alien_digit_msg
\& form_cp_too_large_msg
\& free_tied_hv_pool
\& free_tmps
\& get_and_check_backslash_N_name
\& get_ANYOFHbbm_contents
\& get_ANYOFM_contents
\& get_db_sub
\& get_debug_opts
\& get_deprecated_property_msg
\& getenv_len
\& get_extended_os_errno
\& get_hash_seed
\& get_invlist_iter_addr
\& get_invlist_offset_addr
\& get_invlist_previous_index_addr
\& get_mstats
\& get_prop_definition
\& get_prop_values
\& get_regclass_aux_data
\& get_re_gclass_aux_data
\& get_regex_charset_name
\& get_win32_message_utf8ness
\& gp_free
\& gp_ref
\& grok_bin_oct_hex
\& grok_bslash_c
\& grok_bslash_o
\& grok_bslash_x
\& gv_check
\& gv_fetchmeth_internal
\& gv_override
\& gv_setref
\& gv_stashpvn_internal
\& he_dup
\& hek_dup
\& hfree_next_entry
\& hv_auxalloc
\& hv_common
\& hv_common_key_len
\& hv_delayfree_ent
\& hv_free_ent
\& hv_placeholders_p
\& hv_pushkv
\& hv_rand_set
\& hv_undef_flags
\& import_builtin_bundle
\& infix_plugin_standard
\& init_argv_symbols
\& init_constants
\& init_dbargs
\& init_debugger
\& init_i18nl10n
\& init_named_cv
\& init_stacks
\& init_tm
\& init_uniprops
\& _inverse_folds
\& invert
\& invlist_array
\& _invlist_array_init
\& invlist_clear
\& invlist_clone
\& _invlist_contains_cp
\& invlist_contents
\& _invlist_dump
\& _invlistEQ
\& invlist_extend
\& invlist_highest
\& _invlist_intersection
\& _invlist_intersection_maybe_complement_2nd
\& _invlist_invert
\& invlist_is_iterating
\& invlist_iterfinish
\& invlist_iterinit
\& invlist_iternext
\& _invlist_len
\& invlist_max
\& invlist_previous_index
\& _invlist_search
\& invlist_set_len
\& invlist_set_previous_index
\& _invlist_subtract
\& invlist_trim
\& _invlist_union
\& _invlist_union_maybe_complement_2nd
\& invmap_dump
\& invoke_exception_hook
\& io_close
\& isFF_overlong
\& is_grapheme
\& _is_in_locale_category
\& is_invlist
\& is_standard_filehandle_name
\& _is_uni_FOO
\& _is_uni_perl_idcont
\& _is_uni_perl_idstart
\& is_utf8_char_helper_
\& is_utf8_common
\& is_utf8_FF_helper_
\& _is_utf8_FOO
\& is_utf8_overlong
\& _is_utf8_perl_idcont
\& _is_utf8_perl_idstart
\& jmaybe
\& join_exact
\& keyword
\& keyword_plugin_standard
\& list
\& load_charnames
\& locale_panic
\& localize
\& lossless_NV_to_IV
\& lsbit_pos32
\& lsbit_pos64
\& magic_clear_all_env
\& magic_cleararylen_p
\& magic_clearenv
\& magic_clearhook
\& magic_clearhookall
\& magic_clearisa
\& magic_clearpack
\& magic_clearsig
\& magic_copycallchecker
\& magic_existspack
\& magic_freearylen_p
\& magic_freecollxfrm
\& magic_freemglob
\& magic_freeovrld
\& magic_freeutf8
\& magic_get
\& magic_getarylen
\& magic_getdebugvar
\& magic_getdefelem
\& magic_getnkeys
\& magic_getpack
\& magic_getpos
\& magic_getsig
\& magic_getsubstr
\& magic_gettaint
\& magic_getuvar
\& magic_getvec
\& magic_killbackrefs
\& magic_nextpack
\& magic_regdata_cnt
\& magic_regdatum_get
\& magic_regdatum_set
\& magic_scalarpack
\& magic_set
\& magic_set_all_env
\& magic_setarylen
\& magic_setcollxfrm
\& magic_setdbline
\& magic_setdebugvar
\& magic_setdefelem
\& magic_setenv
\& magic_sethook
\& magic_sethookall
\& magic_setisa
\& magic_setlvref
\& magic_setmglob
\& magic_setnkeys
\& magic_setnonelem
\& magic_setpack
\& magic_setpos
\& magic_setregexp
\& magic_setsig
\& magic_setsigall
\& magic_setsubstr
\& magic_settaint
\& magic_setutf8
\& magic_setuvar
\& magic_setvec
\& magic_sizepack
\& magic_wipepack
\& make_trie
\& malloced_size
\& malloc_good_size
\& markstack_grow
\& mbtowc_
\& mem_collxfrm_
\& mem_log_alloc
\& mem_log_del_sv
\& mem_log_free
\& mem_log_new_sv
\& mem_log_realloc
\& mg_find_mglob
\& mg_size
\& mode_from_discipline
\& more_bodies
\& more_sv
\& moreswitches
\& mortal_getenv
\& mortalized_pv_copy
\& mro_get_private_data
\& mro_meta_dup
\& mro_meta_init
\& msbit_pos32
\& msbit_pos64
\& multiconcat_stringify
\& multideref_stringify
\& my_atof2
\& my_atof3
\& my_attrs
\& my_clearenv
\& my_lstat
\& my_lstat_flags
\& my_memrchr
\& my_mkostemp_cloexec
\& my_mkstemp_cloexec
\& my_stat
\& my_stat_flags
\& my_strerror
\& my_unexec
\& newFORM
\& _new_invlist
\& _new_invlist_C_array
\& newMETHOP_internal
\& newPROG
\& new_stackinfo
\& new_stackinfo_flags
\& newSTUB
\& newSVavdefelem
\& newXS_deffile
\& nextargv
\& no_bareword_allowed
\& no_bareword_filehandle
\& noperl_die
\& notify_parser_that_changed_to_utf8
\& oopsAV
\& oopsHV
\& op_clear
\& op_integerize
\& op_lvalue_flags
\& opmethod_stash
\& op_prune_chain_head
\& op_relocate_sv
\& opslab_force_free
\& opslab_free
\& opslab_free_nopad
\& op_std_init
\& op_varname
\& package
\& package_version
\& pad_add_weakref
\& padlist_store
\& padname_free
\& PadnameIN_SCOPE
\& padnamelist_free
\& parser_dup
\& parser_free
\& parser_free_nexttoke_ops
\& parse_unicode_opts
\& path_is_searchable
\& peep
\& perl_alloc_using
\& perl_clone_using
\& PerlEnv_putenv
\& PerlIO_context_layers
\& PerlIO_restore_errno
\& PerlIO_save_errno
\& PerlLIO_dup_cloexec
\& PerlLIO_dup2_cloexec
\& PerlLIO_open_cloexec
\& PerlLIO_open3_cloexec
\& PerlProc_pipe_cloexec
\& PerlSock_accept_cloexec
\& PerlSock_socket_cloexec
\& PerlSock_socketpair_cloexec
\& perly_sighandler
\& pmruntime
\& POPMARK
\& populate_anyof_bitmap_from_invlist
\& populate_bitmap_from_invlist
\& populate_invlist_from_bitmap
\& populate_isa
\& pregfree
\& pregfree2
\& prepare_export_lexical
\& ptr_hash
\& qerror
\& ReANY
\& reentrant_free
\& reentrant_init
\& reentrant_retry
\& reentrant_size
\& re_exec_indentf
\& ref
\& reg_add_data
\& regcurly
\& regdump
\& regdupe_internal
\& regexec_flags
\& regfree_internal
\& reginitcolors
\& reg_named_buff
\& reg_named_buff_all
\& reg_named_buff_exists
\& reg_named_buff_fetch
\& reg_named_buff_firstkey
\& reg_named_buff_iter
\& reg_named_buff_nextkey
\& reg_named_buff_scalar
\& regnext
\& regnode_after
\& reg_numbered_buff_fetch
\& reg_numbered_buff_fetch_flags
\& reg_numbered_buff_length
\& reg_numbered_buff_store
\& regprop
\& reg_qr_package
\& reg_skipcomment
\& reg_temp_copy
\& re_indentf
\& re_intuit_start
\& re_intuit_string
\& re_op_compile
\& report_evil_fh
\& report_redefined_cv
\& report_wrongway_fh
\& re_printf
\& rpeep
\& rsignal_restore
\& rsignal_save
\& rvpv_dup
\& rxres_save
\& same_dirent
\& save_bool
\& save_clearsv
\& save_delete
\& save_destructor
\& save_destructor_x
\& save_freeop
\& save_freepv
\& save_freesv
\& save_int
\& save_iv
\& save_I8
\& save_I16
\& save_I32
\& save_mortalizesv
\& save_pptr
\& save_pushi32ptr
\& save_pushptrptr
\& save_re_context
\& save_sptr
\& savestack_grow
\& savestack_grow_cnt
\& save_strlen
\& sawparens
\& scalar
\& scalarvoid
\& scan_commit
\& scan_num
\& seed
\& set_ANYOF_arg
\& set_caret_X
\& setfd_cloexec
\& setfd_cloexec_for_nonsysfd
\& setfd_cloexec_or_inhexec_by_sysfdness
\& setfd_inhexec
\& setfd_inhexec_for_sysfd
\& set_numeric_standard
\& set_numeric_underlying
\& set_padlist
\& _setup_canned_invlist
\& share_hek
\& should_warn_nl
\& should_we_output_Debug_r
\& sighandler
\& sighandler1
\& sighandler3
\& single_1bit_pos32
\& single_1bit_pos64
\& Slab_Alloc
\& Slab_Free
\& Slab_to_ro
\& Slab_to_rw
\& softref2xv
\& sortsv_flags_impl
\& ssc_init
\& stack_grow
\& str_to_version
\& strxfrm
\& study_chunk
\& sub_crush_depth
\& sv_add_backref
\& sv_buf_to_ro
\& sv_del_backref
\& sv_i_ncmp
\& sv_i_ncmp_desc
\& sv_2iv
\& sv_magicext_mglob
\& sv_mark_arenas
\& sv_ncmp
\& sv_ncmp_desc
\& sv_only_taint_gmagic
\& sv_or_pv_pos_u2b
\& sv_pvbyten_force_wrapper
\& sv_pvutf8n_force_wrapper
\& sv_resetpvn
\& sv_sethek
\& sv_sweep_arenas
\& SvTRUE_common
\& sv_unglob
\& sv_2uv
\& switch_locale_context
\& sys_init
\& sys_init3
\& sys_intern_clear
\& sys_intern_dup
\& sys_intern_init
\& sys_term
\& tied_method
\& tmps_grow_p
\& _to_fold_latin1
\& TOPMARK
\& to_uni_fold
\& _to_uni_fold_flags
\& to_uni_lower
\& to_uni_title
\& to_uni_upper
\& _to_upper_title_latin1
\& _to_utf8_fold_flags
\& _to_utf8_lower_flags
\& _to_utf8_title_flags
\& _to_utf8_upper_flags
\& translate_substr_offsets
\& try_amagic_bin
\& try_amagic_un
\& uiv_2buf
\& unlnk
\& unshare_hek
\& unwind_paren
\& _utf8n_to_uvchr_msgs_helper
\& utf16_to_utf8_base
\& utf16_to_utf8_reversed
\& utf16_to_utf8
\& utf8_to_uvchr_buf_helper
\& utilize
\& uvoffuni_to_utf8_flags_msgs
\& variant_byte_number
\& varname
\& vivify_defelem
\& vivify_ref
\& wait4pid
\& warn_elem_scalar_context
\& warn_problematic_locale
\& was_lvalue_sub
\& watch
\& win32_croak_not_implemented
\& write_to_stderr
\& xs_boot_epilog
\& xs_handshake
\& yyerror
\& yyerror_pv
\& yyerror_pvn
\& yylex
\& yyparse
\& yyquit
\& yyunlex
.Ve
.PP
Next are the experimental undocumented elements
.PP

.IX Xref "alloc_LOGOP av_remove_offset clear_defarray_simple create_eval_scope cv_ckproto_len_flags cx_popblock cx_popeval cx_popformat cx_popgiven cx_poploop cx_popsub cx_popsub_args cx_popsub_common cx_popwhen cx_pushblock cx_pusheval cx_pushformat cx_pushgiven cx_pushloop_for cx_pushloop_plain cx_pushsub cx_pushtry cx_pushwhen cx_topblock delete_eval_scope do_open_raw do_open6 emulate_cop_io get_re_arg get_vtbl gimme_V hv_backreferences_p hv_kill_backrefs invlist_highest_range_start invlist_lowest newGP new_warnings_bitfield op_refcnt_dec op_refcnt_inc op_unscope pop_stackinfo pp_wrap push_stackinfo rpp_free_2_ rpp_obliterate_stack_to rpp_replace_2_1_COMMON runops_wrap scan_str scan_word scan_word6 skipspace_flags sv_free2 sv_kill_backrefs sv_setpv_freshbuf sv_setsv_cow sv_strftime_ints switch_argstack utf8_to_utf16_base xs_wrap"
.PP
.Vb 10
\& alloc_LOGOP            gimme_V
\& av_remove_offset       hv_backreferences_p
\& clear_defarray_simple  hv_kill_backrefs
\& create_eval_scope      invlist_highest_range_start
\& cv_ckproto_len_flags   invlist_lowest
\& cx_popblock            newGP
\& cx_popeval             new_warnings_bitfield
\& cx_popformat           op_refcnt_dec
\& cx_popgiven            op_refcnt_inc
\& cx_poploop             op_unscope
\& cx_popsub              pop_stackinfo
\& cx_popsub_args         pp_wrap
\& cx_popsub_common       push_stackinfo
\& cx_popwhen             rpp_free_2_
\& cx_pushblock           rpp_obliterate_stack_to
\& cx_pusheval            rpp_replace_2_1_COMMON
\& cx_pushformat          runops_wrap
\& cx_pushgiven           scan_str
\& cx_pushloop_for        scan_word
\& cx_pushloop_plain      scan_word6
\& cx_pushsub             skipspace_flags
\& cx_pushtry             sv_free2
\& cx_pushwhen            sv_kill_backrefs
\& cx_topblock            sv_setpv_freshbuf
\& delete_eval_scope      sv_setsv_cow
\& do_open_raw            sv_strftime_ints
\& do_open6               switch_argstack
\& emulate_cop_io         utf8_to_utf16_base
\& get_re_arg             xs_wrap
\& get_vtbl
.Ve
.PP
Finally are the deprecated undocumented elements.
Do not use any for new code; remove all occurrences of all of these from
existing code.
.PP

.IX Xref "get_no_modify get_opargs get_ppaddr uvuni_to_utf8"
.PP
.Vb 1
\& get_no_modify  get_opargs  get_ppaddr  uvuni_to_utf8
.Ve
.SH AUTHORS
.IX Header "AUTHORS"
The autodocumentation system was originally added to the Perl core by
Benjamin Stuhl.  Documentation is by whoever was kind enough to
document their functions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIconfig.h\fR, perlapi, perlapio, perlcall, perlclib, perlembed, perlfilter, perlguts, perlhacktips, perlinterp, perliol, perlmroapi, perlreapi, perlreguts, perlxs
